// ==== ESP32 OBD-II PID poller + Firestore ingest (TWAI NORMAL @ 500k) ====
// Pins: GPIO22 -> CTX, GPIO21 -> CRX  |  Secret: "american"

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "driver/twai.h"
#include <math.h>

// ---------- EDIT ----------
const char* WIFI_SSID    = "YOUR_WIFI";
const char* WIFI_PASS    = "YOUR_PASS";
const char* FUNC_URL     = "https://us-central1-olads-guardian.cloudfunctions.net/ingestCan";
const char* DEVICE_SECRET= "american";
const char* DEVICE_ID    = "esp32-van-01";

#define TWAI_TX_PIN GPIO_NUM_22
#define TWAI_RX_PIN GPIO_NUM_21

struct Frame { uint32_t ts, id; uint8_t dlc; uint8_t data[8]; };

static bool wifiConnect() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi");
  uint32_t t0 = millis();
  while (WiFi.status()!=WL_CONNECTED && millis()-t0<20000) { delay(300); Serial.print("."); }
  Serial.println();
  if (WiFi.status()==WL_CONNECTED) { Serial.printf("WiFi OK, IP: %s\n", WiFi.localIP().toString().c_str()); return true; }
  Serial.println("WiFi FAILED"); return false;
}

static bool canInitNormal() {
  twai_general_config_t g = TWAI_GENERAL_CONFIG_DEFAULT(TWAI_TX_PIN, TWAI_RX_PIN, TWAI_MODE_NORMAL);
  twai_timing_config_t  t = TWAI_TIMING_CONFIG_500KBITS();   // OBD-II 500k
  twai_filter_config_t  f = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  if (twai_driver_install(&g, &t, &f) != ESP_OK) return false;
  if (twai_start() != ESP_OK) return false;
  return true;
}

static void pushFromMsg(Frame& dst, const twai_message_t& m) {
  dst.ts  = millis();
  dst.id  = (m.flags & TWAI_MSG_FLAG_EXTD) ? m.identifier : (m.identifier & 0x7FF);
  dst.dlc = m.data_length_code;
  for (int i=0;i<dst.dlc && i<8;i++) dst.data[i] = m.data[i];
}

static bool sendBatchWithMeta(const Frame* frames, int count,
                              float batt, float coolant, float rpm,
                              float stft_b1, float ltft_b1, float stft_b2, float ltft_b2,
                              long runtime_s)
{
  WiFiClientSecure client; client.setInsecure();
  HTTPClient http;
  if (!http.begin(client, FUNC_URL)) { Serial.println("HTTP begin failed"); return false; }
  http.addHeader("Content-Type", "application/json");
  http.addHeader("x-device-secret", DEVICE_SECRET);

  StaticJsonDocument<8192> doc;
  doc["device_id"] = DEVICE_ID;

  JsonObject meta = doc.createNestedObject("meta");
  // set only if valid
  if (!isnan(batt))      meta["battery_v"] = batt;
  if (!isnan(coolant))   meta["coolant_c"] = coolant;
  if (!isnan(rpm))       meta["rpm"]       = rpm;
  if (!isnan(stft_b1))   meta["stft_b1"]   = stft_b1;
  if (!isnan(ltft_b1))   meta["ltft_b1"]   = ltft_b1;
  if (!isnan(stft_b2))   meta["stft_b2"]   = stft_b2;
  if (!isnan(ltft_b2))   meta["ltft_b2"]   = ltft_b2;
  if (runtime_s >= 0)    meta["runtime_s"] = runtime_s;

  JsonArray arr = doc.createNestedArray("frames");
  for (int i=0;i<count;i++) {
    JsonObject f = arr.createNestedObject();
    f["ts"]  = frames[i].ts;
    f["id"]  = frames[i].id;
    f["dlc"] = frames[i].dlc;
    JsonArray d = f.createNestedArray("data");
    for (int b=0;b<frames[i].dlc;b++) d.add(frames[i].data[b]);
  }

  String payload; serializeJson(doc, payload);
  int code = http.POST((uint8_t*)payload.c_str(), payload.length());
  String resp = http.getString();
  Serial.printf("POST %d\n", code);
  if (code != 200) Serial.println(resp);
  http.end();
  return code==200;
}

// Decode helpers
static float decodeTemp(uint8_t A){ return (float)A - 40.0f; }                 // PID 05 (Â°C)
static float decodeRPM(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/4.0f; }     // PID 0C (rpm)
static float decodeVoltage(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/1000.0f; } // PID 42 (V)
static float decodeTrim(uint8_t A){ return ((float)A - 128.0f) * 100.0f / 128.0f; } // PIDs 06â€“09 (%)
static long  decodeU16(uint8_t A,uint8_t B){ return (long)(A*256 + B); }       // PID 1F (s)

// Send one OBD-II request and collect responses for that PID
static void requestPID(uint8_t pid, Frame* out, int& idx, int max,
                       float& batt, float& coolant, float& rpm,
                       float& stft_b1, float& ltft_b1, float& stft_b2, float& ltft_b2,
                       long& runtime_s)
{
  if (idx >= max) return;

  twai_message_t tx = {};
  tx.identifier = 0x7DF;               // functional broadcast
  tx.flags = TWAI_MSG_FLAG_NONE;       // 11-bit std
  tx.data_length_code = 8;
  tx.data[0] = 0x02;                    // 2 data bytes follow
  tx.data[1] = 0x01;                    // Service 01: current data
  tx.data[2] = pid;                     // PID
  tx.data[3] = tx.data[4] = tx.data[5] = tx.data[6] = tx.data[7] = 0x00;

  if (twai_transmit(&tx, pdMS_TO_TICKS(50)) == ESP_OK) {
    Frame f; pushFromMsg(f, tx);
    if (idx < max) out[idx++] = f;
    Serial.printf("ðŸ“¤ Sent STD PID 0x%02X on ID 0x7DF\n", pid);
  } else {
    Serial.printf("TX failed for PID 0x%02X\n", pid);
    return;
  }

  // Collect responses (typ. 0x7E8..0x7EF). Wait ~60 ms.
  uint32_t t0 = millis();
  while (millis() - t0 < 60 && idx < max) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(5)) == ESP_OK) {
      Frame f; pushFromMsg(f, rx);
      out[idx++] = f;

      // Positive response: 0x40 | 0x01 = 0x41; PID echoes in byte 2
      if ((rx.data_length_code >= 3) && rx.data[1] == 0x41 && rx.data[2] == pid) {
        uint8_t A = (rx.data_length_code > 3) ? rx.data[3] : 0;
        uint8_t B = (rx.data_length_code > 4) ? rx.data[4] : 0;
        uint8_t C = (rx.data_length_code > 5) ? rx.data[5] : 0;
        uint8_t D = (rx.data_length_code > 6) ? rx.data[6] : 0;

        switch (pid) {
          case 0x05: coolant = decodeTemp(A); break;
          case 0x0C: rpm     = decodeRPM(A,B); break;
          case 0x42: batt    = decodeVoltage(A,B); break;
          case 0x1F: runtime_s = decodeU16(A,B); break;
          case 0x06: stft_b1 = decodeTrim(A); break;
          case 0x07: ltft_b1 = decodeTrim(A); break;
          case 0x08: stft_b2 = decodeTrim(A); break;
          case 0x09: ltft_b2 = decodeTrim(A); break;
        }
      }
    }
  }
}

void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\nOLADS OBD-II poller â†’ Firestore");
  Serial.println(FUNC_URL);

  wifiConnect();

  if (!canInitNormal()) {
    Serial.println("CAN init FAILED (3.3V transceiver, pins 22/21, RS/EN low, 500k, termination OK)");
    while(1) delay(1000);
  }
  Serial.println("CAN NORMAL @ 500 kbps");
}

void loop() {
  // Metrics weâ€™ll parse (start as NaN / -1)
  float batt=NAN, coolant=NAN, rpm=NAN, stft_b1=NAN, ltft_b1=NAN, stft_b2=NAN, ltft_b2=NAN;
  long runtime_s = -1;

  static Frame buf[128];
  int idx = 0;

  // Query the PIDs you want:
  const uint8_t pids[] = {0x0C,0x05,0x42,0x1F,0x06,0x07,0x08,0x09};
  for (uint8_t pid : pids) {
    requestPID(pid, buf, idx, 128, batt, coolant, rpm, stft_b1, ltft_b1, stft_b2, ltft_b2, runtime_s);
    delay(20);
  }

  // Print parsed results
  Serial.printf("RPM=%.0f  Coolant=%.1fÂ°C  Batt=%.2fV  Runtime=%lds  STFT1=%.1f%%  LTFT1=%.1f%%  STFT2=%.1f%%  LTFT2=%.1f%%\n",
    rpm, coolant, batt, runtime_s, stft_b1, ltft_b1, stft_b2, ltft_b2);

  // Ship to Firestore (raw frames + meta)
  if (idx>0) sendBatchWithMeta(buf, idx, batt, coolant, rpm, stft_b1, ltft_b1, stft_b2, ltft_b2, runtime_s);

  // Poll every ~1s
  delay(1000);
}
