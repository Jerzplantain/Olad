// --- Put the type FIRST so Arduino's auto-prototypes see it ---
struct Frame {
  unsigned long ts;
  unsigned long id;
  unsigned char dlc;
  unsigned char data[8];
  bool is_ext;
};

// ==== ESP32 OBD-II → Supabase (mph + °F + full PID set + misfire flags/index) ====
// Pins: ESP32 GPIO22 -> CAN TXD, GPIO21 -> CAN RXD
// OBD-II: pin 6=CANH, pin 14=CANL, pin 5=Signal GND (tie to board GND)

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "driver/twai.h"
#include <math.h>
#include <ctype.h>

// ---------------- USER CONFIG ----------------
const char* WIFI_SSID = "iPhone";
const char* WIFI_PASS = "american";

// Supabase (host + path form)
const char* SUPABASE_HOST = "zhrlppnknfjxhwhfsdxd.supabase.co";
const char* SENSOR_PATH   = "/rest/v1/sensor_data";
const char* RAW_PATH      = "/rest/v1/can_raw";
String SUPABASE_KEY       = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpocmxwcG5rbmZqeGh3aGZzZHhkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1NjY3NjIsImV4cCI6MjA3MjE0Mjc2Mn0.EVrzx09YwDglwFUCjS3hKbrg2Wdy1hjSPV1gWxnN_yU";

// CAN pins and options
#define TWAI_TX_PIN     GPIO_NUM_22
#define TWAI_RX_PIN     GPIO_NUM_21
#define TRANS_STB_PIN   -1     // set to a valid GPIO if your transceiver has RS/STB/EN; otherwise leave -1

// Posting/queue sizes
#define RAW_CHUNK_SIZE     32
#define MAX_RAW_PER_LOOP   64
#define LISTEN_FIRST_MS    600

// Poll pacing
#define SLOW_LOOP_EVERY    5    // run "slow" PID set every N loops

// Candidate 29-bit ECU source addresses (Honda-friendly)
static const uint8_t kCandidateExtECUs[] = { 0x0E, 0x10, 0x33 };
static inline uint32_t makeExtReqId(uint8_t ecu){
  return ((uint32_t)0x18<<24)|((uint32_t)0xDA<<16)|((uint32_t)ecu<<8)|0xF1;
}

// VIN becomes our vehicle_id after discovery
String vehicle_id = "unknown";

// ---------------- GLOBALS ----------------
WiFiClientSecure secureClient;
HTTPClient http;

// --- simple rolling stats for “misfire_index” ---
static const int STAT_N = 16;
static float rpm_hist[STAT_N];     // filled with NAN initially
static float stft_hist[STAT_N];
static int   stat_idx = 0;
static bool  stat_inited = false;
static inline void stat_push(float rpm, float stft){
  if (!stat_inited) {
    for (int i=0;i<STAT_N;i++){ rpm_hist[i]=NAN; stft_hist[i]=NAN; }
    stat_inited = true;
  }
  rpm_hist[stat_idx]  = rpm;
  stft_hist[stat_idx] = stft;
  stat_idx = (stat_idx + 1) % STAT_N;
}
static void stat_mean_std(const float* v, float& mean, float& stddev){
  int n=0; mean=0; stddev=0;
  for (int i=0;i<STAT_N;i++){ if (!isnan(v[i])){ mean += v[i]; n++; } }
  if (n==0){ mean=NAN; stddev=NAN; return; }
  mean /= n;
  float acc=0; for (int i=0;i<STAT_N;i++){ if (!isnan(v[i])){ float d=v[i]-mean; acc += d*d; } }
  stddev = sqrtf(acc / n);
}

// ---------------- WIFI ----------------
static bool wifiConnect() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi");
  uint32_t t0 = millis();
  while (WiFi.status()!=WL_CONNECTED && millis()-t0<20000) { delay(300); Serial.print("."); }
  Serial.println();
  if (WiFi.status()==WL_CONNECTED) {
    Serial.printf("WiFi OK, IP: %s  RSSI=%d dBm\n", WiFi.localIP().toString().c_str(), WiFi.RSSI());
    return true;
  }
  Serial.println("WiFi FAILED");
  return false;
}
static void ensureWifi() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi dropped — reconnecting...");
    wifiConnect();
  }
}

// ---------------- CAN/TWAI ----------------
static bool canInstallStart(twai_mode_t mode){
  if (TRANS_STB_PIN >= 0){ pinMode(TRANS_STB_PIN, OUTPUT); digitalWrite(TRANS_STB_PIN, LOW); delay(2); }
  twai_general_config_t g = TWAI_GENERAL_CONFIG_DEFAULT(TWAI_TX_PIN, TWAI_RX_PIN, mode);
  g.rx_queue_len = 256;   // bigger RX queue
  g.tx_queue_len = 16;
  g.alerts_enabled = TWAI_ALERT_RX_QUEUE_FULL | TWAI_ALERT_ERR_PASS | TWAI_ALERT_ARB_LOST |
                     TWAI_ALERT_TX_FAILED | TWAI_ALERT_BUS_OFF | TWAI_ALERT_BUS_RECOVERED;
  twai_timing_config_t  t = TWAI_TIMING_CONFIG_500KBITS();
  twai_filter_config_t  f = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  if (twai_driver_install(&g, &t, &f) != ESP_OK) return false;
  if (twai_start() != ESP_OK) return false;
  return true;
}
static bool canInitNormal() { return canInstallStart(TWAI_MODE_NORMAL); }

// Copy TWAI → Frame
static inline void pushFromMsg(Frame& dst, const twai_message_t& m) {
  dst.ts  = millis();
  bool ext = (m.flags & TWAI_MSG_FLAG_EXTD);
  dst.id  = ext ? m.identifier : (m.identifier & 0x7FF);
  dst.is_ext = ext;
  dst.dlc = m.data_length_code;
  for (int i=0;i<dst.dlc && i<8;i++) dst.data[i] = m.data[i];
}

// ---------------- Supabase ----------------
static bool httpBeginHostPath(HTTPClient& cli, const char* host, const char* path) {
  return cli.begin(secureClient, host, 443, path, true); // https + SNI
}
static bool supabasePostJson(const char* path, const String& payload) {
  ensureWifi();
  if (!httpBeginHostPath(http, SUPABASE_HOST, path)) { Serial.println("HTTP begin failed"); return false; }
  http.setTimeout(15000);
  secureClient.setTimeout(15000);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("apikey", SUPABASE_KEY);
  http.addHeader("Authorization", "Bearer " + SUPABASE_KEY);
  http.addHeader("Prefer", "return=minimal");
  int code = http.POST((uint8_t*)payload.c_str(), payload.length());
  String resp = http.getString();
  Serial.printf("POST %d to https://%s%s\n", code, SUPABASE_HOST, path);
  if (code < 200 || code >= 300) { Serial.println(resp); http.end(); return false; }
  http.end(); return true;
}

// ---------------- Posting helpers ----------------
static String toHexBytes(const uint8_t* data, uint8_t len) {
  char buf[3]; String s;
  for (uint8_t i=0;i<len;i++) { if (i) s += ' '; snprintf(buf, sizeof(buf), "%02X", data[i]); s += buf; }
  return s;
}
static bool postRawFramesBatch(const Frame* frames, int count) {
  int limit = min(count, MAX_RAW_PER_LOOP);
  int sent = 0;
  while (sent < limit) {
    int n = min(RAW_CHUNK_SIZE, limit - sent);
    StaticJsonDocument<4096> doc; JsonArray arr = doc.to<JsonArray>();
    for (int i=0;i<n;i++) {
      const Frame& fr = frames[sent + i];
      JsonObject r = arr.createNestedObject();
      r["vehicle_id"] = vehicle_id;
      r["vin"]        = vehicle_id;
      r["can_id"]     = (int)fr.id;
      r["is_ext"]     = fr.is_ext;
      r["dlc"]        = (int)fr.dlc;
      r["data_hex"]   = toHexBytes(fr.data, fr.dlc);
      r["ts_ms"]      = (long long)fr.ts;
    }
    String payload; serializeJson(doc, payload);
    if (!supabasePostJson(RAW_PATH, payload)) return false;
    sent += n;
  }
  return true;
}

// ---------------- Decoders ----------------
static float decodeTempC(uint8_t A){ return (float)A - 40.0f; }                  // °C
static float C_to_F(float c){ return isnan(c) ? NAN : (c * 9.0f/5.0f + 32.0f); } // °F
static float decodeRPM(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/4.0f; }       // rpm
static float decodeVoltage(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/1000.0f; } // V
static float decodeTrim(uint8_t A){ return ((float)A - 128.0f) * 100.0f / 128.0f; } // %
static long  decodeU16(uint8_t A,uint8_t B){ return (long)(A*256 + B); }
static float decodePct(uint8_t A){ return (float)A * 100.0f / 255.0f; }          // %
static float decodeMAF(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/100.0f; }     // g/s
static float decodeLambdaCmd(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/32768.0f; } // λ
static float decodeCatTempC(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/10.0f - 40.0f; } // °C
static float decodeFuelRateLph(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/20.0f; } // L/h

// ---------------- Address helpers ----------------
static inline bool isDiag11(uint32_t id){ return (id>=0x7E8 && id<=0x7EF); }
static inline bool isDiag29(uint32_t id){ return ( (id & 0x1FFF0000) == 0x18DA0000 ); }
static inline bool isExpectedExtResp(uint32_t id){
  if (!isDiag29(id)) return false;
  uint8_t dest = (id >> 8) & 0xFF; // should be 0xF1 (tester)
  return dest == 0xF1;
}
static uint32_t reqIdFromResp(const twai_message_t& rx){
  if (rx.flags & TWAI_MSG_FLAG_EXTD){
    if (isDiag29(rx.identifier)) {
      uint8_t src = rx.identifier & 0xFF; // ECU src
      return makeExtReqId(src);
    }
  } else {
    if (isDiag11(rx.identifier)) return rx.identifier - 8; // 0x7E8 -> 0x7E0
  }
  return 0x7E0;
}
static void sendFlowControlToECU_forResp(const twai_message_t& rx){
  twai_message_t fc={};
  fc.identifier = reqIdFromResp(rx);
  fc.flags = (rx.flags & TWAI_MSG_FLAG_EXTD) ? TWAI_MSG_FLAG_EXTD : TWAI_MSG_FLAG_NONE;
  fc.data_length_code=8;
  fc.data[0]=0x30; fc.data[1]=0x00; fc.data[2]=0x00; // CTS, BS=0, STmin=0
  for (int i=3;i<8;i++) fc.data[i]=0x00;
  (void)twai_transmit(&fc, pdMS_TO_TICKS(50));
}
static void sendTesterPresent(uint32_t reqId, bool ext){
  twai_message_t m={};
  m.identifier=reqId; m.flags= ext?TWAI_MSG_FLAG_EXTD:TWAI_MSG_FLAG_NONE; m.data_length_code=8;
  m.data[0]=0x02; m.data[1]=0x3E; m.data[2]=0x00; for(int i=3;i<8;i++) m.data[i]=0x00;
  (void)twai_transmit(&m, pdMS_TO_TICKS(50));
}
static void sendTesterPresent_All(){
  for (uint8_t ecu : kCandidateExtECUs) sendTesterPresent(makeExtReqId(ecu), true);
  sendTesterPresent(0x7E0, false);
}

// ---------------- VIN (Mode 09 PID 02) ----------------
static bool requestVIN_once(uint32_t reqId, bool ext) {
  twai_message_t tx = {};
  tx.identifier = reqId;
  tx.flags = ext ? TWAI_MSG_FLAG_EXTD : TWAI_MSG_FLAG_NONE;
  tx.data_length_code = 8;
  tx.data[0] = 0x02;  // 09 02 = VIN
  tx.data[1] = 0x09;
  tx.data[2] = 0x02;
  for (int i=3;i<8;i++) tx.data[i]=0x00;

  if (twai_transmit(&tx, pdMS_TO_TICKS(60)) != ESP_OK) {
    Serial.printf("TX failed for VIN @%s 0x%08X\n", ext?"EXT":"STD", reqId);
    return false;
  }
  Serial.printf("📤 VIN request @%s 0x%08X\n", ext?"EXT":"STD", reqId);

  char vinbuf[32]; uint8_t vinlen = 0;
  char partBuf[3][8]; uint8_t partLen[3] = {0,0,0}; bool gotPart[3] = {false,false,false};
  bool sawFF=false;

  uint32_t t0 = millis();
  while (millis() - t0 < 1500) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(20)) != ESP_OK) continue;

    bool fromExpected = ext ? ((rx.flags & TWAI_MSG_FLAG_EXTD) && isExpectedExtResp(rx.identifier))
                            : (!(rx.flags & TWAI_MSG_FLAG_EXTD) && isDiag11(rx.identifier));
    if (!fromExpected) continue;

    const uint8_t *d = rx.data; uint8_t dlc = rx.data_length_code;

    // ISO-TP First Frame
    if ((d[0] & 0xF0) == 0x10 && dlc >= 6 && d[2]==0x49 && d[3]==0x02) {
      sawFF = true; sendFlowControlToECU_forResp(rx);
      for (uint8_t i=5; i<dlc && vinlen<31; i++){ char c=(char)d[i]; if(c>=' '&&c<='~') vinbuf[vinlen++]=c; }
      continue;
    }
    // ISO-TP Consecutive Frame
    if ((d[0] & 0xF0) == 0x20 && dlc >= 2 && sawFF) {
      for (uint8_t i=1; i<dlc && vinlen<31; i++){ char c=(char)d[i]; if(c>=' '&&c<='~') vinbuf[vinlen++]=c; }
      continue;
    }
    // 49 02 01/02/03 chunks
    if (dlc >= 4 && d[1]==0x49 && d[2]==0x02) {
      uint8_t part = d[3]; if (part>=1 && part<=3){
        uint8_t idx=part-1, start=4, len=(dlc>start)?(dlc-start):0; if (len>7) len=7;
        for (uint8_t i=0;i<len;i++) partBuf[idx][i]=(char)d[start+i];
        partLen[idx]=len; gotPart[idx]=true;
      }
    }
  }

  String vin;
  if (vinlen){ for (uint8_t i=0;i<vinlen;i++) if (vinbuf[i] != ' ') vin += vinbuf[i]; }
  else { for (uint8_t p=0;p<3;p++) if (gotPart[p]) for (uint8_t i=0;i<partLen[p];i++) if (partBuf[p][i] != ' ') vin += partBuf[p][i]; }

  if (vin.length()>17) vin=vin.substring(0,17);
  if (vin.length()>=11) { vehicle_id = vin; Serial.printf("✅ VIN detected: %s\n", vehicle_id.c_str()); return true; }
  return false;
}
static void requestVIN() {
  for (uint8_t ecu : kCandidateExtECUs) if (requestVIN_once(makeExtReqId(ecu), true)) return;
  if (requestVIN_once(0x7E0, false)) return;
  if (requestVIN_once(0x7DF, false)) return;
  Serial.println("⚠ VIN not found, using default 'unknown'");
}

// ---------------- PID request/parse ----------------
static void parsePositivePID(uint8_t pid, const twai_message_t& rx,
  float& batt, float& coolant_c, float& coolant_f, float& rpm, long& runtime_s,
  float& stft_b1, float& ltft_b1, float& stft_b2, float& ltft_b2,
  // extended set:
  float& speed_kph, float& speed_mph, float& load_pct,
  float& maf_gps, float& map_kpa, float& iat_c, float& tps_pct,
  float& baro_kpa, float& lambda_cmd,
  float& af_lambda_b1s1,            // wideband stub
  float& cat_b1s1_c, float& cat_b1s2_c, float& cat_b2s1_c, float& cat_b2s2_c,
  float& oil_temp_c, float& fuel_rate_lph,
  float& fuel_level_pct, float& ethanol_pct)
{
  const uint8_t* d=rx.data; uint8_t dlc=rx.data_length_code;
  if (dlc<5 || d[1]!=0x41 || d[2]!=pid) return;

  uint8_t A=d[3], B=d[4];

  switch(pid){
    // core set
    case 0x05: coolant_c = decodeTempC(A); coolant_f = C_to_F(coolant_c); break;
    case 0x0C: rpm        = decodeRPM(A,B); break;
    case 0x42: batt       = decodeVoltage(A,B); break;
    case 0x1F: runtime_s  = decodeU16(A,B); break;
    case 0x06: stft_b1    = decodeTrim(A); break;
    case 0x07: ltft_b1    = decodeTrim(A); break;
    case 0x08: stft_b2    = decodeTrim(A); break;
    case 0x09: ltft_b2    = decodeTrim(A); break;

    // extended set
    case 0x0D: speed_kph  = (float)A; speed_mph = speed_kph * 0.621371f; break;
    case 0x04: load_pct   = decodePct(A); break;
    case 0x10: maf_gps    = decodeMAF(A,B); break;
    case 0x0B: map_kpa    = (float)A; break;
    case 0x0F: iat_c      = decodeTempC(A); break;
    case 0x11: tps_pct    = decodePct(A); break;
    case 0x33: baro_kpa   = (float)A; break;
    case 0x44: lambda_cmd = decodeLambdaCmd(A,B); break;

    case 0x24: af_lambda_b1s1 = decodeLambdaCmd(A,B); break;   // wideband (if supported)

    case 0x3C: cat_b1s1_c = decodeCatTempC(A,B); break;
    case 0x3D: cat_b2s1_c = decodeCatTempC(A,B); break;
    case 0x3E: cat_b1s2_c = decodeCatTempC(A,B); break;
    case 0x3F: cat_b2s2_c = decodeCatTempC(A,B); break;

    case 0x5C: oil_temp_c = decodeTempC(A); break;             // oil temp (°C)
    case 0x5E: fuel_rate_lph = decodeFuelRateLph(A,B); break;  // L/h
    case 0x2F: fuel_level_pct = decodePct(A); break;           // %
    case 0x52: ethanol_pct = decodePct(A); break;              // %
    default: break;
  }
}
static inline bool isPositiveForPid(const twai_message_t& rx, uint8_t pid){
  const uint8_t* d=rx.data; uint8_t dlc=rx.data_length_code;
  return (dlc>=5 && d[1]==0x41 && d[2]==pid);
}

static bool requestPID_once(uint8_t pid, uint32_t reqId, bool ext,
                       Frame* out, int& idx, int max,
                       float& batt, float& coolant_c, float& coolant_f, float& rpm, long& runtime_s,
                       float& stft_b1, float& ltft_b1, float& stft_b2, float& ltft_b2,
                       float& speed_kph, float& speed_mph, float& load_pct,
                       float& maf_gps, float& map_kpa, float& iat_c, float& tps_pct,
                       float& baro_kpa, float& lambda_cmd,
                       float& af_lambda_b1s1,
                       float& cat_b1s1_c, float& cat_b1s2_c, float& cat_b2s1_c, float& cat_b2s2_c,
                       float& oil_temp_c, float& fuel_rate_lph,
                       float& fuel_level_pct, float& ethanol_pct,
                       int& rx_count)
{
  if (idx >= max) return false;

  twai_message_t tx = {};
  tx.identifier = reqId;
  tx.flags = ext ? TWAI_MSG_FLAG_EXTD : TWAI_MSG_FLAG_NONE;
  tx.data_length_code = 8;
  tx.data[0] = 0x02;  // Service 01
  tx.data[1] = 0x01;
  tx.data[2] = pid;
  for (int i=3;i<8;i++) tx.data[i]=0x00;

  if (twai_transmit(&tx, pdMS_TO_TICKS(60)) != ESP_OK) {
    Serial.printf("TX failed for PID 0x%02X @%s 0x%08X\n", pid, ext?"EXT":"STD", reqId);
    return false;
  }
  Serial.printf("📤 PID 0x%02X @%s 0x%08X\n", pid, ext?"EXT":"STD", reqId);

  uint32_t t0 = millis(); bool gotPositive=false;
  while (millis() - t0 < 450 && idx < max) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(10)) == ESP_OK) {
      bool fromExpected = ext ? ((rx.flags & TWAI_MSG_FLAG_EXTD) && isExpectedExtResp(rx.identifier))
                              : (!(rx.flags & TWAI_MSG_FLAG_EXTD) && isDiag11(rx.identifier));
      if (!fromExpected) continue;

      // If multi-frame, send FlowControl
      if ((rx.data[0] & 0xF0) == 0x10 && rx.data_length_code>=3) sendFlowControlToECU_forResp(rx);

      Frame f; pushFromMsg(f, rx); out[idx++] = f; rx_count++;

      if (isPositiveForPid(rx, pid)) {
        gotPositive = true;
        parsePositivePID(pid, rx,
          batt, coolant_c, coolant_f, rpm, runtime_s,
          stft_b1, ltft_b1, stft_b2, ltft_b2,
          speed_kph, speed_mph, load_pct,
          maf_gps, map_kpa, iat_c, tps_pct,
          baro_kpa, lambda_cmd,
          af_lambda_b1s1,
          cat_b1s1_c, cat_b1s2_c, cat_b2s1_c, cat_b2s2_c,
          oil_temp_c, fuel_rate_lph,
          fuel_level_pct, ethanol_pct);
      }
    }
  }
  return gotPositive;
}

static void requestPID_sweep(uint8_t pid, Frame* out, int& idx, int max,
                             float& batt, float& coolant_c, float& coolant_f, float& rpm, long& runtime_s,
                             float& stft_b1, float& ltft_b1, float& stft_b2, float& ltft_b2,
                             float& speed_kph, float& speed_mph, float& load_pct,
                             float& maf_gps, float& map_kpa, float& iat_c, float& tps_pct,
                             float& baro_kpa, float& lambda_cmd,
                             float& af_lambda_b1s1,
                             float& cat_b1s1_c, float& cat_b1s2_c, float& cat_b2s1_c, float& cat_b2s2_c,
                             float& oil_temp_c, float& fuel_rate_lph,
                             float& fuel_level_pct, float& ethanol_pct,
                             int& rx_count)
{
  for (uint8_t ecu : kCandidateExtECUs)
    if (requestPID_once(pid, makeExtReqId(ecu), true, out,idx,max,
        batt,coolant_c,coolant_f,rpm,runtime_s, stft_b1,ltft_b1,stft_b2,ltft_b2,
        speed_kph,speed_mph,load_pct, maf_gps,map_kpa,iat_c,tps_pct,
        baro_kpa,lambda_cmd, af_lambda_b1s1,
        cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c, oil_temp_c,fuel_rate_lph,
        fuel_level_pct,ethanol_pct, rx_count)) return;

  if (requestPID_once(pid, 0x7E0, false, out,idx,max,
        batt,coolant_c,coolant_f,rpm,runtime_s, stft_b1,ltft_b1,stft_b2,ltft_b2,
        speed_kph,speed_mph,load_pct, maf_gps,map_kpa,iat_c,tps_pct,
        baro_kpa,lambda_cmd, af_lambda_b1s1,
        cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c, oil_temp_c,fuel_rate_lph,
        fuel_level_pct,ethanol_pct, rx_count)) return;

  (void)requestPID_once(pid, 0x7DF, false, out,idx,max,
        batt,coolant_c,coolant_f,rpm,runtime_s, stft_b1,ltft_b1,stft_b2,ltft_b2,
        speed_kph,speed_mph,load_pct, maf_gps,map_kpa,iat_c,tps_pct,
        baro_kpa,lambda_cmd, af_lambda_b1s1,
        cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c, oil_temp_c,fuel_rate_lph,
        fuel_level_pct,ethanol_pct, rx_count);
}

// ---------------- DTCs (Modes 03, 07, 0A) ----------------
static char dtcBuf[512]; // CSV buffer
static String dtcCSV;

static char dtcTypeChar(uint8_t type){ return (type==0)?'P':(type==1)?'C':(type==2)?'B':'U'; }
static String decodeDTC(uint8_t b1, uint8_t b2){
  if (b1==0 && b2==0) return String();
  uint8_t type = (b1 & 0xC0) >> 6;
  uint8_t d1   = (b1 & 0x30) >> 4;
  uint8_t d2   = (b1 & 0x0F);
  uint8_t d3   = (b2 & 0xF0) >> 4;
  uint8_t d4   = (b2 & 0x0F);
  char s[6]; snprintf(s,sizeof(s), "%c%01u%01u%01u%01u", dtcTypeChar(type), d1,d2,d3,d4);
  return String(s);
}

static void requestDTC(uint8_t service, bool& p030_present, uint8_t misfire_cyl[8]) {
  // clear return accumulators
  p030_present = false;
  for (int i=0;i<8;i++) ; // leave counts/presence accumulation to caller

  // Try ext ECUs then 7E0/7DF
  uint32_t reqs[6]; bool exts[6];
  int r=0;
  for (uint8_t ecu: kCandidateExtECUs){ reqs[r]=makeExtReqId(ecu); exts[r]=true; r++; }
  reqs[r]=0x7E0; exts[r]=false; r++;
  reqs[r]=0x7DF; exts[r]=false; r++;

  uint8_t respSvc = 0x40 + service;
  bool anyFound=false;

  for (int k=0;k<r;k++){
    uint32_t reqId=reqs[k]; bool ext=exts[k];

    twai_message_t tx={};
    tx.identifier=reqId; tx.flags = ext?TWAI_MSG_FLAG_EXTD:TWAI_MSG_FLAG_NONE; tx.data_length_code=8;
    tx.data[0]=0x02; tx.data[1]=service; tx.data[2]=0x00; for(int i=3;i<8;i++) tx.data[i]=0x00;
    if (twai_transmit(&tx, pdMS_TO_TICKS(60)) != ESP_OK) continue;

    uint8_t agg[128]; int alen=0;
    bool collecting=false, sawFF=false;
    uint32_t t0=millis();

    while (millis()-t0 < 600 && alen < (int)sizeof(agg)){
      twai_message_t rx;
      if (twai_receive(&rx, pdMS_TO_TICKS(20)) != ESP_OK) continue;
      bool fromExpected = ext ? ((rx.flags & TWAI_MSG_FLAG_EXTD) && isExpectedExtResp(rx.identifier))
                              : (!(rx.flags & TWAI_MSG_FLAG_EXTD) && isDiag11(rx.identifier));
      if (!fromExpected) continue;
      const uint8_t *d=rx.data; uint8_t dlc=rx.data_length_code;

      // First frame?
      if ((d[0] & 0xF0) == 0x10 && dlc>=4 && d[2]==respSvc){
        sawFF=true; collecting=true; sendFlowControlToECU_forResp(rx);
        for (int i=3;i<dlc && alen<(int)sizeof(agg); i++) agg[alen++]=d[i];
        continue;
      }
      // Consecutive frame
      if ((d[0] & 0xF0) == 0x20 && dlc>=2 && collecting){
        for (int i=1;i<dlc && alen<(int)sizeof(agg); i++) agg[alen++]=d[i];
        continue;
      }
      // Single frame
      if ((d[0] >= 0x02 && d[0] <= 0x07) && dlc>=3 && d[1]==respSvc){
        collecting=true;
        for (int i=2;i<dlc && alen<(int)sizeof(agg); i++) agg[alen++]=d[i];
        // no continue; let loop time out quickly
      }
    }

    if (!collecting || alen==0) continue;
    anyFound=true;

    // Parse pairs into CSV
    for (int i=0;i+1<alen; i+=2){
      String code = decodeDTC(agg[i], agg[i+1]);
      if (code.length()==0) continue;
      if (dtcCSV.length()) dtcCSV += ",";
      dtcCSV += code;

      // Misfire flags from P030x
      if (code.startsWith("P030")){
        p030_present = true;
        int cyl = code.substring(4).toInt(); // "P0301" -> 1
        if (cyl>=1 && cyl<=8) misfire_cyl[cyl-1] = 1; // mark presence
      }
    }
    // If we got some, stop trying other IDs to reduce load
    if (dtcCSV.length()) break;
  }
}

// ---------------- Post parsed sensor_data ----------------
static bool postSensorData(
  float batt, float coolant_c, float coolant_f, float rpm, long runtime_s,
  float stft_b1, float ltft_b1, float stft_b2, float ltft_b2,
  float speed_kph, float speed_mph, float load_pct,
  float maf_gps, float map_kpa, float iat_c, float tps_pct,
  float baro_kpa, float lambda_cmd,
  float af_lambda_b1s1,
  float cat_b1s1_c, float cat_b1s2_c, float cat_b2s1_c, float cat_b2s2_c,
  float oil_temp_c, float fuel_rate_lph,
  float fuel_level_pct, float ethanol_pct,
  // new misfire-related:
  float misfire_index, bool misfire_alert,
  const String& dtc_csv,
  const uint8_t misfire_cyl[8])
{
  StaticJsonDocument<1700> doc;
  doc["vehicle_id"] = vehicle_id;
  doc["vin"]        = vehicle_id;

  // core fields
  if (!isnan(batt))      doc["batt"]      = batt;
  if (!isnan(coolant_c)) doc["coolant"]   = coolant_c;   // °C (compat)
  if (!isnan(coolant_f)) doc["coolant_f"] = coolant_f;   // °F
  if (!isnan(rpm))       doc["rpm"]       = rpm;
  if (runtime_s >= 0)    doc["runtime_s"] = runtime_s;

  if (!isnan(stft_b1))   doc["stft_b1"]   = stft_b1;
  if (!isnan(ltft_b1))   doc["ltft_b1"]   = ltft_b1;
  if (!isnan(stft_b2))   doc["stft_b2"]   = stft_b2;
  if (!isnan(ltft_b2))   doc["ltft_b2"]   = ltft_b2;

  // extended
  if (!isnan(speed_kph)) doc["speed_kph"] = speed_kph;
  if (!isnan(speed_mph)) doc["speed_mph"] = speed_mph;
  if (!isnan(load_pct))  doc["load_pct"]  = load_pct;
  if (!isnan(maf_gps))   doc["maf_gps"]   = maf_gps;
  if (!isnan(map_kpa))   doc["map_kpa"]   = map_kpa;
  if (!isnan(iat_c))     doc["iat_c"]     = iat_c;
  if (!isnan(tps_pct))   doc["tps_pct"]   = tps_pct;
  if (!isnan(baro_kpa))  doc["baro_kpa"]  = baro_kpa;
  if (!isnan(lambda_cmd))doc["lambda_cmd"]= lambda_cmd;

  if (!isnan(af_lambda_b1s1)) doc["af_lambda_b1s1"] = af_lambda_b1s1;

  if (!isnan(cat_b1s1_c)) doc["cat_b1s1_c"] = cat_b1s1_c;
  if (!isnan(cat_b1s2_c)) doc["cat_b1s2_c"] = cat_b1s2_c;
  if (!isnan(cat_b2s1_c)) doc["cat_b2s1_c"] = cat_b2s1_c;
  if (!isnan(cat_b2s2_c)) doc["cat_b2s2_c"] = cat_b2s2_c;

  if (!isnan(oil_temp_c))     doc["oil_temp_c"]     = oil_temp_c;
  if (!isnan(fuel_rate_lph))  doc["fuel_rate_lph"]  = fuel_rate_lph;
  if (!isnan(fuel_level_pct)) doc["fuel_level_pct"] = fuel_level_pct;
  if (!isnan(ethanol_pct))    doc["ethanol_pct"]    = ethanol_pct;

  // misfire-related
  if (!isnan(misfire_index))  doc["misfire_index"]  = misfire_index;
  doc["misfire_alert"] = misfire_alert;
  if (dtc_csv.length())       doc["dtc_csv"]        = dtc_csv;

  // per-cylinder flags if present (1..8)
  for (int c=0;c<8;c++){
    if (misfire_cyl[c]) {
      char key[16]; snprintf(key,sizeof(key),"misfire_cyl%d", c+1);
      doc[key] = (int)misfire_cyl[c];
    }
  }

  String payload; serializeJson(doc, payload);
  return supabasePostJson(SENSOR_PATH, payload);
}

// ---------------- Arduino entrypoints ----------------
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\nESP32 OBD-II → Supabase (mph + °F + full PID set + misfire flags/index)");

  wifiConnect();
  secureClient.setInsecure();   // dev: skip CA; for prod, pin LE R3

  // Brief listen-only sniff
  if (!canInstallStart(TWAI_MODE_LISTEN_ONLY)) {
    Serial.println("CAN LISTEN_ONLY init FAILED (check transceiver power, pins 22/21, termination)");
    while(1) delay(1000);
  }
  Serial.println("TWAI LISTEN_ONLY @ 500 kbps (sniffing briefly)");
  uint32_t t0=millis(); int sniff_rx=0;
  while (millis()-t0<LISTEN_FIRST_MS) { twai_message_t rx; if (twai_receive(&rx, pdMS_TO_TICKS(5))==ESP_OK) sniff_rx++; }
  Serial.printf("Sniff window done: frames=%d\n", sniff_rx);

  // Switch to NORMAL
  twai_stop(); twai_driver_uninstall(); delay(40);
  if (!canInitNormal()) {
    Serial.println("CAN NORMAL init FAILED (check transceiver power, pins 22/21, termination)");
    while(1) delay(1000);
  }
  Serial.println("CAN NORMAL @ 500 kbps");
}

void loop() {
  ensureWifi();

  // Keep ECUs awake
  static uint32_t lastTP=0;
  if (millis()-lastTP > 2000) { sendTesterPresent_All(); lastTP=millis(); }

  // Metrics
  float batt=NAN, coolant_c=NAN, coolant_f=NAN, rpm=NAN; long runtime_s = -1;
  float stft_b1=NAN, ltft_b1=NAN, stft_b2=NAN, ltft_b2=NAN;

  float speed_kph=NAN, speed_mph=NAN, load_pct=NAN;
  float maf_gps=NAN, map_kpa=NAN, iat_c=NAN, tps_pct=NAN;
  float baro_kpa=NAN, lambda_cmd=NAN, af_lambda_b1s1=NAN;
  float cat_b1s1_c=NAN, cat_b1s2_c=NAN, cat_b2s1_c=NAN, cat_b2s2_c=NAN;
  float oil_temp_c=NAN, fuel_rate_lph=NAN, fuel_level_pct=NAN, ethanol_pct=NAN;

  static Frame buf[256];
  int idx = 0;
  int rx_count = 0;

  // FAST set (2–5 Hz)
  const uint8_t pids_fast[] = {
    0x0C, 0x0D, 0x05, 0x10, 0x0B, 0x0F, 0x11, 0x04, 0x42, 0x06,0x07,0x08,0x09
  };
  for (uint8_t pid : pids_fast) {
    requestPID_sweep(pid, buf, idx, 256,
      batt,coolant_c,coolant_f,rpm,runtime_s, stft_b1,ltft_b1,stft_b2,ltft_b2,
      speed_kph,speed_mph,load_pct, maf_gps,map_kpa,iat_c,tps_pct,
      baro_kpa,lambda_cmd, af_lambda_b1s1,
      cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c, oil_temp_c,fuel_rate_lph,
      fuel_level_pct,ethanol_pct,
      rx_count);
    delay(120);
  }

  // SLOW set (every N loops)
  static uint32_t loopCounter=0;
  if ((loopCounter % SLOW_LOOP_EVERY) == 0) {
    const uint8_t pids_slow[] = { 0x01, 0x33, 0x44, 0x24, 0x3C,0x3D,0x3E,0x3F, 0x5C, 0x5E, 0x2F, 0x52 };
    for (uint8_t pid : pids_slow) {
      requestPID_sweep(pid, buf, idx, 256,
        batt,coolant_c,coolant_f,rpm,runtime_s, stft_b1,ltft_b1,stft_b2,ltft_b2,
        speed_kph,speed_mph,load_pct, maf_gps,map_kpa,iat_c,tps_pct,
        baro_kpa,lambda_cmd, af_lambda_b1s1,
        cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c, oil_temp_c,fuel_rate_lph,
        fuel_level_pct,ethanol_pct,
        rx_count);
      delay(150);
    }
  }
  loopCounter++;

  // Try VIN after first replies
  static bool triedVIN = false;
  if (!triedVIN && rx_count > 0 && vehicle_id == "unknown") { triedVIN = true; requestVIN(); }

  // ---- DTCs & misfire flags every SLOW cycle ----
  bool misfireByDTC=false;
  uint8_t misfire_cyl[8]={0,0,0,0,0,0,0,0};
  dtcCSV = "";
  if ((loopCounter % SLOW_LOOP_EVERY) == 0) {
    bool tmp=false;
    requestDTC(0x07, tmp, misfire_cyl); // pending
    misfireByDTC |= tmp;
    requestDTC(0x03, tmp, misfire_cyl); // stored
    misfireByDTC |= tmp;
    requestDTC(0x0A, tmp, misfire_cyl); // permanent
    misfireByDTC |= tmp;
  }

  // ---- Misfire heuristic (index 0..1) ----
  stat_push(rpm, stft_b1);
  float rpm_mean, rpm_std; stat_mean_std(rpm_hist, rpm_mean, rpm_std);
  float stft_mean, stft_std; stat_mean_std(stft_hist, stft_mean, stft_std);

  float misfire_index = NAN; bool misfire_alert = false;
  if (!isnan(rpm_mean) && rpm_mean>400 && rpm_mean<3000 && !isnan(rpm_std)) {
    float rpm_var_norm = rpm_std / max(500.0f, rpm_mean);   // normalize roughness
    float stft_norm    = isnan(stft_std)?0.0f:(stft_std/20.0f);
    float base = rpm_var_norm*3.0f + stft_norm*1.0f;
    // idle emphasis
    if (!isnan(speed_mph) && speed_mph < 3.0f) base *= 1.2f;
    misfire_index = fminf(fmaxf(base, 0.0f), 1.0f);
    misfire_alert = (misfire_index > 0.70f) || misfireByDTC;
  }

  // ---- Serial (mph + °F) ----
  Serial.printf(
    "VIN=%s RX=%d RPM=%s Spd=%s mph ECT=%s°F Batt=%sV "
    "LOAD=%s%% MAF=%s g/s MAP=%s kPa IAT=%s°C TP=%s%% λcmd=%s "
    "Oil=%s°C FuelLvl=%s%% FuelRate=%s L/h  MisIdx=%s Alert=%s DTCs=[%s]\n",
    vehicle_id.c_str(), rx_count,
    isnan(rpm)?"-":String(rpm,0).c_str(),
    isnan(speed_mph)?"-":String(speed_mph,0).c_str(),
    isnan(coolant_f)?"-":String(coolant_f,1).c_str(),
    isnan(batt)?"-":String(batt,2).c_str(),
    isnan(load_pct)?"-":String(load_pct,0).c_str(),
    isnan(maf_gps)?"-":String(maf_gps,1).c_str(),
    isnan(map_kpa)?"-":String(map_kpa,0).c_str(),
    isnan(iat_c)?"-":String(iat_c,1).c_str(),
    isnan(tps_pct)?"-":String(tps_pct,0).c_str(),
    isnan(lambda_cmd)?"-":String(lambda_cmd,3).c_str(),
    isnan(oil_temp_c)?"-":String(oil_temp_c,1).c_str(),
    isnan(fuel_level_pct)?"-":String(fuel_level_pct,0).c_str(),
    isnan(fuel_rate_lph)?"-":String(fuel_rate_lph,2).c_str(),
    isnan(misfire_index)?"-":String(misfire_index,2).c_str(),
    misfire_alert?"YES":"no",
    dtcCSV.c_str()
  );

  // Upload if we got replies
  if (rx_count > 0) {
    bool haveParsed =
      (!isnan(rpm) || !isnan(coolant_c) || !isnan(batt) || !isnan(speed_mph) ||
       !isnan(load_pct) || !isnan(maf_gps) || !isnan(map_kpa) || !isnan(iat_c) ||
       !isnan(tps_pct) || !isnan(baro_kpa) || !isnan(lambda_cmd) ||
       !isnan(af_lambda_b1s1) || !isnan(cat_b1s1_c) || !isnan(cat_b1s2_c) ||
       !isnan(cat_b2s1_c) || !isnan(cat_b2s2_c) || !isnan(oil_temp_c) ||
       !isnan(fuel_rate_lph) || !isnan(fuel_level_pct) || !isnan(ethanol_pct) ||
       !isnan(misfire_index) || misfire_alert || dtcCSV.length() > 0 ||
       runtime_s >= 0 || !isnan(stft_b1) || !isnan(ltft_b1) || !isnan(stft_b2) || !isnan(ltft_b2));

    if (haveParsed) {
      postSensorData(
        batt,coolant_c,coolant_f,rpm,runtime_s,
        stft_b1,ltft_b1,stft_b2,ltft_b2,
        speed_kph,speed_mph,load_pct,
        maf_gps,map_kpa,iat_c,tps_pct,
        baro_kpa,lambda_cmd,
        af_lambda_b1s1,
        cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c,
        oil_temp_c,fuel_rate_lph,
        fuel_level_pct,ethanol_pct,
        misfire_index, misfire_alert,
        dtcCSV, misfire_cyl
      );
    }
    if (idx > 0)    postRawFramesBatch(buf, idx);
  } else {
    Serial.println("ECU appears asleep (or TX not ACKed). Skipping uploads this cycle.");
  }

  delay(1000);
}
