// --- Put the type FIRST so Arduino's auto-prototypes see it ---
struct Frame {
  unsigned long ts;
  unsigned long id;
  unsigned char dlc;
  unsigned char data[8];
  bool is_ext;
};

// ==== ESP32 OBD-II PID poller â†’ Supabase (VIN as vehicle_id + extra PIDs) ====
// Pins: ESP32 GPIO22 -> CAN TXD, GPIO21 -> CAN RXD
// OBD-II: pin 6=CANH, pin 14=CANL, pin 5=GND (tie to board GND). Pin 4 chassis GND optional.

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "driver/twai.h"
#include <math.h>
#include <ctype.h>

// ---------------- USER CONFIG ----------------
const char* WIFI_SSID = "Galaxy";
const char* WIFI_PASS = "american";

// Supabase (host + path form)
const char* SUPABASE_HOST = "zhrlppnknfjxhwhfsdxd.supabase.co";
const char* SENSOR_PATH   = "/rest/v1/sensor_data";
const char* RAW_PATH      = "/rest/v1/can_raw";
String SUPABASE_KEY       = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpocmxwcG5rbmZqeGh3aGZzZHhkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1NjY3NjIsImV4cCI6MjA3MjE0Mjc2Mn0.EVrzx09YwDglwFUCjS3hKbrg2Wdy1hjSPV1gWxnN_yU";

// CAN pins and options
#define TWAI_TX_PIN     GPIO_NUM_22
#define TWAI_RX_PIN     GPIO_NUM_21
#define TRANS_STB_PIN   -1     // set to a valid GPIO if your board exposes RS/STB/EN; otherwise leave -1

// Posting/queue sizes
#define RAW_CHUNK_SIZE     32
#define MAX_RAW_PER_LOOP   64
#define LISTEN_FIRST_MS    600

// Poll pacing
#define SLOW_LOOP_EVERY    5    // run "slow" PID set every N loops

// Try these Honda 29-bit ECU source addresses first
static const uint8_t kCandidateExtECUs[] = { 0x0E, 0x10, 0x33 };
static inline uint32_t makeExtReqId(uint8_t ecu){
  return ((uint32_t)0x18<<24)|((uint32_t)0xDA<<16)|((uint32_t)ecu<<8)|0xF1;
}

// VIN becomes our vehicle_id after discovery
String vehicle_id = "unknown";

// ---------------- GLOBALS ----------------
WiFiClientSecure secureClient;
HTTPClient http;

// ---------------- WIFI ----------------
static bool wifiConnect() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi");
  uint32_t t0 = millis();
  while (WiFi.status()!=WL_CONNECTED && millis()-t0<20000) { delay(300); Serial.print("."); }
  Serial.println();
  if (WiFi.status()==WL_CONNECTED) {
    Serial.printf("WiFi OK, IP: %s  RSSI=%d dBm\n", WiFi.localIP().toString().c_str(), WiFi.RSSI());
    return true;
  }
  Serial.println("WiFi FAILED");
  return false;
}
static void ensureWifi() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi dropped â€” reconnecting...");
    wifiConnect();
  }
}

// ---------------- CAN/TWAI ----------------
static bool canInstallStart(twai_mode_t mode){
  if (TRANS_STB_PIN >= 0){ pinMode(TRANS_STB_PIN, OUTPUT); digitalWrite(TRANS_STB_PIN, LOW); delay(2); }
  twai_general_config_t g = TWAI_GENERAL_CONFIG_DEFAULT(TWAI_TX_PIN, TWAI_RX_PIN, mode);
  g.rx_queue_len = 256;   // bigger RX queue
  g.tx_queue_len = 16;
  g.alerts_enabled = TWAI_ALERT_RX_QUEUE_FULL | TWAI_ALERT_ERR_PASS | TWAI_ALERT_ARB_LOST |
                     TWAI_ALERT_TX_FAILED | TWAI_ALERT_BUS_OFF | TWAI_ALERT_BUS_RECOVERED;
  twai_timing_config_t  t = TWAI_TIMING_CONFIG_500KBITS();
  twai_filter_config_t  f = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  if (twai_driver_install(&g, &t, &f) != ESP_OK) return false;
  if (twai_start() != ESP_OK) return false;
  return true;
}
static bool canInitNormal() { return canInstallStart(TWAI_MODE_NORMAL); }

// Helper to convert TWAI msg -> Frame
static inline void pushFromMsg(Frame& dst, const twai_message_t& m) {
  dst.ts  = millis();
  bool ext = (m.flags & TWAI_MSG_FLAG_EXTD);
  dst.id  = ext ? m.identifier : (m.identifier & 0x7FF);
  dst.is_ext = ext;
  dst.dlc = m.data_length_code;
  for (int i=0;i<dst.dlc && i<8;i++) dst.data[i] = m.data[i];
}

// ---------------- Supabase ----------------
static bool httpBeginHostPath(HTTPClient& cli, const char* host, const char* path) {
  return cli.begin(secureClient, host, 443, path, true); // https + SNI
}
static bool supabasePostJson(const char* path, const String& payload) {
  ensureWifi();
  if (!httpBeginHostPath(http, SUPABASE_HOST, path)) { Serial.println("HTTP begin failed"); return false; }
  http.setTimeout(15000);
  secureClient.setTimeout(15000);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("apikey", SUPABASE_KEY);
  http.addHeader("Authorization", "Bearer " + SUPABASE_KEY);
  http.addHeader("Prefer", "return=minimal");
  int code = http.POST((uint8_t*)payload.c_str(), payload.length());
  String resp = http.getString();
  Serial.printf("POST %d to https://%s%s\n", code, SUPABASE_HOST, path);
  if (code < 200 || code >= 300) { Serial.println(resp); http.end(); return false; }
  http.end(); return true;
}

// ---------------- Posting helpers ----------------
static String toHexBytes(const uint8_t* data, uint8_t len) {
  char buf[3]; String s;
  for (uint8_t i=0;i<len;i++) { if (i) s += ' '; snprintf(buf, sizeof(buf), "%02X", data[i]); s += buf; }
  return s;
}
static bool postRawFramesBatch(const Frame* frames, int count) {
  int limit = min(count, MAX_RAW_PER_LOOP);
  int sent = 0;
  while (sent < limit) {
    int n = min(RAW_CHUNK_SIZE, limit - sent);
    StaticJsonDocument<4096> doc; JsonArray arr = doc.to<JsonArray>();
    for (int i=0;i<n;i++) {
      const Frame& fr = frames[sent + i];
      JsonObject r = arr.createNestedObject();
      r["vehicle_id"] = vehicle_id;
      r["vin"]        = vehicle_id;
      r["can_id"]     = (int)fr.id;
      r["is_ext"]     = fr.is_ext;
      r["dlc"]        = (int)fr.dlc;
      r["data_hex"]   = toHexBytes(fr.data, fr.dlc);
      r["ts_ms"]      = (long long)fr.ts;
    }
    String payload; serializeJson(doc, payload);
    if (!supabasePostJson(RAW_PATH, payload)) return false;
    sent += n;
  }
  return true;
}

// ---------------- Decoders ----------------
static float decodeTemp(uint8_t A){ return (float)A - 40.0f; }
static float decodeRPM(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/4.0f; }
static float decodeVoltage(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/1000.0f; }
static float decodeTrim(uint8_t A){ return ((float)A - 128.0f) * 100.0f / 128.0f; }
static long  decodeU16(uint8_t A,uint8_t B){ return (long)(A*256 + B); }
static float decodePct(uint8_t A){ return (float)A * 100.0f / 255.0f; }
static float decodeMAF(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/100.0f; }      // g/s
static float decodeLambdaCmd(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/32768.0f; } // equivalence ratio
static float decodeCatTemp(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/10.0f - 40.0f; } // Â°C
static float decodeFuelRate(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/20.0f; }   // L/h

// ---------------- Address/ISO-TP helpers ----------------
static inline bool isDiag11(uint32_t id){ return (id>=0x7E8 && id<=0x7EF); }
static inline bool isDiag29(uint32_t id){ return ( (id & 0x1FFF0000) == 0x18DA0000 ); }
static inline bool isExpectedExtResp(uint32_t id){
  if (!isDiag29(id)) return false;
  uint8_t dest = (id >> 8) & 0xFF; // should be 0xF1 (tester)
  return dest == 0xF1;
}
static uint32_t reqIdFromResp(const twai_message_t& rx){
  if (rx.flags & TWAI_MSG_FLAG_EXTD){
    if (isDiag29(rx.identifier)) {
      uint8_t src = rx.identifier & 0xFF; // ECU src
      return makeExtReqId(src);
    }
  } else {
    if (isDiag11(rx.identifier)) return rx.identifier - 8; // 0x7E8 -> 0x7E0
  }
  return 0x7E0;
}
static void sendFlowControlToECU_forResp(const twai_message_t& rx){
  twai_message_t fc={};
  fc.identifier = reqIdFromResp(rx);
  fc.flags = (rx.flags & TWAI_MSG_FLAG_EXTD) ? TWAI_MSG_FLAG_EXTD : TWAI_MSG_FLAG_NONE;
  fc.data_length_code=8;
  fc.data[0]=0x30; fc.data[1]=0x00; fc.data[2]=0x00; // CTS, BS=0, STmin=0
  for (int i=3;i<8;i++) fc.data[i]=0x00;
  (void)twai_transmit(&fc, pdMS_TO_TICKS(50));
}
static void sendTesterPresent(uint32_t reqId, bool ext){
  twai_message_t m={};
  m.identifier=reqId; m.flags= ext?TWAI_MSG_FLAG_EXTD:TWAI_MSG_FLAG_NONE; m.data_length_code=8;
  m.data[0]=0x02; m.data[1]=0x3E; m.data[2]=0x00; for(int i=3;i<8;i++) m.data[i]=0x00;
  (void)twai_transmit(&m, pdMS_TO_TICKS(50));
}
static void sendTesterPresent_All(){
  for (uint8_t ecu : kCandidateExtECUs) sendTesterPresent(makeExtReqId(ecu), true);
  sendTesterPresent(0x7E0, false);
}

// ---------------- VIN (Mode 09 PID 02) ----------------
static bool requestVIN_once(uint32_t reqId, bool ext) {
  twai_message_t tx = {};
  tx.identifier = reqId;
  tx.flags = ext ? TWAI_MSG_FLAG_EXTD : TWAI_MSG_FLAG_NONE;
  tx.data_length_code = 8;
  tx.data[0] = 0x02;  // Service 09, PID 02 (VIN)
  tx.data[1] = 0x09;
  tx.data[2] = 0x02;
  for (int i=3;i<8;i++) tx.data[i]=0x00;

  if (twai_transmit(&tx, pdMS_TO_TICKS(60)) != ESP_OK) {
    Serial.printf("TX failed for VIN @%s 0x%08X\n", ext?"EXT":"STD", reqId);
    return false;
  }
  Serial.printf("ðŸ“¤ VIN request @%s 0x%08X\n", ext?"EXT":"STD", reqId);

  char vinbuf[32]; uint8_t vinlen = 0;
  char partBuf[3][8]; uint8_t partLen[3] = {0,0,0}; bool gotPart[3] = {false,false,false};
  bool sawFF=false;

  uint32_t t0 = millis();
  while (millis() - t0 < 1500) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(20)) != ESP_OK) continue;

    bool fromExpected = ext ? ((rx.flags & TWAI_MSG_FLAG_EXTD) && isExpectedExtResp(rx.identifier))
                            : (!(rx.flags & TWAI_MSG_FLAG_EXTD) && isDiag11(rx.identifier));
    if (!fromExpected) continue;

    const uint8_t *d = rx.data; uint8_t dlc = rx.data_length_code;

    // ISO-TP First Frame
    if ((d[0] & 0xF0) == 0x10 && dlc >= 6 && d[2]==0x49 && d[3]==0x02) {
      sawFF = true; sendFlowControlToECU_forResp(rx);
      for (uint8_t i=5; i<dlc && vinlen<31; i++){ char c=(char)d[i]; if(c>=' '&&c<='~') vinbuf[vinlen++]=c; }
      continue;
    }
    // ISO-TP Consecutive Frame
    if ((d[0] & 0xF0) == 0x20 && dlc >= 2 && sawFF) {
      for (uint8_t i=1; i<dlc && vinlen<31; i++){ char c=(char)d[i]; if(c>=' '&&c<='~') vinbuf[vinlen++]=c; }
      continue;
    }
    // 49 02 01/02/03 chunks
    if (dlc >= 4 && d[1]==0x49 && d[2]==0x02) {
      uint8_t part = d[3]; if (part>=1 && part<=3){
        uint8_t idx=part-1, start=4, len=(dlc>start)?(dlc-start):0; if (len>7) len=7;
        for (uint8_t i=0;i<len;i++) partBuf[idx][i]=(char)d[start+i];
        partLen[idx]=len; gotPart[idx]=true;
      }
    }
  }

  String vin;
  if (vinlen){ for (uint8_t i=0;i<vinlen;i++) if (vinbuf[i] != ' ') vin += vinbuf[i]; }
  else { for (uint8_t p=0;p<3;p++) if (gotPart[p]) for (uint8_t i=0;i<partLen[p];i++) if (partBuf[p][i] != ' ') vin += partBuf[p][i]; }

  if (vin.length()>17) vin=vin.substring(0,17);
  if (vin.length()>=11) { vehicle_id = vin; Serial.printf("âœ… VIN detected: %s\n", vehicle_id.c_str()); return true; }
  return false;
}
static void requestVIN() {
  for (uint8_t ecu : kCandidateExtECUs) if (requestVIN_once(makeExtReqId(ecu), true)) return;
  if (requestVIN_once(0x7E0, false)) return;
  if (requestVIN_once(0x7DF, false)) return;
  Serial.println("âš  VIN not found, using default 'unknown'");
}

// ---------------- PID request/parse ----------------
static void parsePositivePID(uint8_t pid, const twai_message_t& rx,
  float& batt, float& coolant, float& rpm, long& runtime_s,
  float& stft_b1, float& ltft_b1, float& stft_b2, float& ltft_b2,
  // new metrics:
  float& speed_kph, float& speed_mph, float& load_pct,
  float& maf_gps, float& map_kpa, float& iat_c, float& tps_pct,
  float& baro_kpa, float& lambda_cmd,
  float& af_lambda_b1s1,           // wideband stub (if supported)
  float& cat_b1s1_c, float& cat_b1s2_c, float& cat_b2s1_c, float& cat_b2s2_c,
  float& oil_temp_c, float& fuel_rate_lph)
{
  const uint8_t* d=rx.data; uint8_t dlc=rx.data_length_code;
  if (dlc<3) return;
  if (!(dlc>=5 && d[1]==0x41 && d[2]==pid)) return;

  uint8_t A = (dlc>3)?d[3]:0;
  uint8_t B = (dlc>4)?d[4]:0;
  uint8_t C = (dlc>5)?d[5]:0;
  uint8_t D = (dlc>6)?d[6]:0;
  (void)C; (void)D;

  switch(pid){
    // existing
    case 0x05: coolant = decodeTemp(A); break;
    case 0x0C: rpm     = decodeRPM(A,B); break;
    case 0x42: batt    = decodeVoltage(A,B); break;
    case 0x1F: runtime_s = decodeU16(A,B); break;
    case 0x06: stft_b1 = decodeTrim(A); break;
    case 0x07: ltft_b1 = decodeTrim(A); break;
    case 0x08: stft_b2 = decodeTrim(A); break;
    case 0x09: ltft_b2 = decodeTrim(A); break;

    // additions
    case 0x0D: speed_kph = (float)A; speed_mph = speed_kph * 0.621371f; break;
    case 0x04: load_pct  = decodePct(A); break;
    case 0x10: maf_gps   = decodeMAF(A,B); break;
    case 0x0B: map_kpa   = (float)A; break;
    case 0x0F: iat_c     = decodeTemp(A); break;
    case 0x11: tps_pct   = decodePct(A); break;
    case 0x33: baro_kpa  = (float)A; break;
    case 0x44: lambda_cmd = decodeLambdaCmd(A,B); break;

    // wideband lambda (PID 0x24 example; many vehicles donâ€™t support; treat as lambda only)
    case 0x24: // O2S1 equivalence ratio (A,B) and current/voltage (C,D)
      af_lambda_b1s1 = decodeLambdaCmd(A,B); break;

    // catalyst temps
    case 0x3C: cat_b1s1_c = decodeCatTemp(A,B); break;
    case 0x3D: cat_b2s1_c = decodeCatTemp(A,B); break;
    case 0x3E: cat_b1s2_c = decodeCatTemp(A,B); break;
    case 0x3F: cat_b2s2_c = decodeCatTemp(A,B); break;

    // oil temp
    case 0x52: oil_temp_c = decodeTemp(A); break;

    // fuel rate
    case 0x5E: fuel_rate_lph = decodeFuelRate(A,B); break;

    default: break;
  }
}
static inline bool isPositiveForPid(const twai_message_t& rx, uint8_t pid){
  const uint8_t* d=rx.data; uint8_t dlc=rx.data_length_code;
  return (dlc>=5 && d[1]==0x41 && d[2]==pid);
}

static bool requestPID_once(uint8_t pid, uint32_t reqId, bool ext,
                       Frame* out, int& idx, int max,
                       float& batt, float& coolant, float& rpm, long& runtime_s,
                       float& stft_b1, float& ltft_b1, float& stft_b2, float& ltft_b2,
                       float& speed_kph, float& speed_mph, float& load_pct,
                       float& maf_gps, float& map_kpa, float& iat_c, float& tps_pct,
                       float& baro_kpa, float& lambda_cmd,
                       float& af_lambda_b1s1,
                       float& cat_b1s1_c, float& cat_b1s2_c, float& cat_b2s1_c, float& cat_b2s2_c,
                       float& oil_temp_c, float& fuel_rate_lph,
                       int& rx_count)
{
  if (idx >= max) return false;

  twai_message_t tx = {};
  tx.identifier = reqId;
  tx.flags = ext ? TWAI_MSG_FLAG_EXTD : TWAI_MSG_FLAG_NONE;
  tx.data_length_code = 8;
  tx.data[0] = 0x02;  // Service 01
  tx.data[1] = 0x01;
  tx.data[2] = pid;
  for (int i=3;i<8;i++) tx.data[i]=0x00;

  if (twai_transmit(&tx, pdMS_TO_TICKS(60)) != ESP_OK) {
    Serial.printf("TX failed for PID 0x%02X @%s 0x%08X\n", pid, ext?"EXT":"STD", reqId);
    return false;
  }
  Serial.printf("ðŸ“¤ PID 0x%02X @%s 0x%08X\n", pid, ext?"EXT":"STD", reqId);

  uint32_t t0 = millis(); bool gotPositive=false;
  while (millis() - t0 < 450 && idx < max) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(10)) == ESP_OK) {
      bool fromExpected = ext ? ((rx.flags & TWAI_MSG_FLAG_EXTD) && isExpectedExtResp(rx.identifier))
                              : (!(rx.flags & TWAI_MSG_FLAG_EXTD) && isDiag11(rx.identifier));
      if (!fromExpected) continue;

      // If multi-frame, send FlowControl
      if ((rx.data[0] & 0xF0) == 0x10 && rx.data_length_code>=3) sendFlowControlToECU_forResp(rx);

      Frame f; pushFromMsg(f, rx); out[idx++] = f; rx_count++;

      if (isPositiveForPid(rx, pid)) {
        gotPositive = true;
        parsePositivePID(pid, rx,
          batt, coolant, rpm, runtime_s,
          stft_b1, ltft_b1, stft_b2, ltft_b2,
          speed_kph, speed_mph, load_pct,
          maf_gps, map_kpa, iat_c, tps_pct,
          baro_kpa, lambda_cmd,
          af_lambda_b1s1,
          cat_b1s1_c, cat_b1s2_c, cat_b2s1_c, cat_b2s2_c,
          oil_temp_c, fuel_rate_lph);
      }
    }
  }
  return gotPositive;
}

static void requestPID_sweep(uint8_t pid, Frame* out, int& idx, int max,
                             float& batt, float& coolant, float& rpm, long& runtime_s,
                             float& stft_b1, float& ltft_b1, float& stft_b2, float& ltft_b2,
                             float& speed_kph, float& speed_mph, float& load_pct,
                             float& maf_gps, float& map_kpa, float& iat_c, float& tps_pct,
                             float& baro_kpa, float& lambda_cmd,
                             float& af_lambda_b1s1,
                             float& cat_b1s1_c, float& cat_b1s2_c, float& cat_b2s1_c, float& cat_b2s2_c,
                             float& oil_temp_c, float& fuel_rate_lph,
                             int& rx_count)
{
  for (uint8_t ecu : kCandidateExtECUs)
    if (requestPID_once(pid, makeExtReqId(ecu), true, out,idx,max,
        batt,coolant,rpm,runtime_s, stft_b1,ltft_b1,stft_b2,ltft_b2,
        speed_kph,speed_mph,load_pct, maf_gps,map_kpa,iat_c,tps_pct,
        baro_kpa,lambda_cmd, af_lambda_b1s1,
        cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c, oil_temp_c,fuel_rate_lph, rx_count)) return;

  if (requestPID_once(pid, 0x7E0, false, out,idx,max,
        batt,coolant,rpm,runtime_s, stft_b1,ltft_b1,stft_b2,ltft_b2,
        speed_kph,speed_mph,load_pct, maf_gps,map_kpa,iat_c,tps_pct,
        baro_kpa,lambda_cmd, af_lambda_b1s1,
        cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c, oil_temp_c,fuel_rate_lph, rx_count)) return;

  (void)requestPID_once(pid, 0x7DF, false, out,idx,max,
        batt,coolant,rpm,runtime_s, stft_b1,ltft_b1,stft_b2,ltft_b2,
        speed_kph,speed_mph,load_pct, maf_gps,map_kpa,iat_c,tps_pct,
        baro_kpa,lambda_cmd, af_lambda_b1s1,
        cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c, oil_temp_c,fuel_rate_lph, rx_count);
}

// ---------------- Posting parsed sensor_data ----------------
static bool postSensorData(
  float batt, float coolant, float rpm, long runtime_s,
  float stft_b1, float ltft_b1, float stft_b2, float ltft_b2,
  float speed_kph, float speed_mph, float load_pct,
  float maf_gps, float map_kpa, float iat_c, float tps_pct,
  float baro_kpa, float lambda_cmd,
  float af_lambda_b1s1,
  float cat_b1s1_c, float cat_b1s2_c, float cat_b2s1_c, float cat_b2s2_c,
  float oil_temp_c, float fuel_rate_lph)
{
  StaticJsonDocument<1024> doc;
  doc["vehicle_id"] = vehicle_id;
  doc["vin"]        = vehicle_id;

  // existing fields
  if (!isnan(batt))      doc["batt"]      = batt;
  if (!isnan(coolant))   doc["coolant"]   = coolant;
  if (!isnan(rpm))       doc["rpm"]       = rpm;
  if (runtime_s >= 0)    doc["runtime_s"] = runtime_s;
  if (!isnan(stft_b1))   doc["stft_b1"]   = stft_b1;
  if (!isnan(ltft_b1))   doc["ltft_b1"]   = ltft_b1;
  if (!isnan(stft_b2))   doc["stft_b2"]   = stft_b2;
  if (!isnan(ltft_b2))   doc["ltft_b2"]   = ltft_b2;

  // new fields (ensure columns exist in Supabase)
  if (!isnan(speed_kph)) doc["speed_kph"] = speed_kph;
  if (!isnan(speed_mph)) doc["speed_mph"] = speed_mph;
  if (!isnan(load_pct))  doc["load_pct"]  = load_pct;
  if (!isnan(maf_gps))   doc["maf_gps"]   = maf_gps;
  if (!isnan(map_kpa))   doc["map_kpa"]   = map_kpa;
  if (!isnan(iat_c))     doc["iat_c"]     = iat_c;
  if (!isnan(tps_pct))   doc["tps_pct"]   = tps_pct;
  if (!isnan(baro_kpa))  doc["baro_kpa"]  = baro_kpa;
  if (!isnan(lambda_cmd))doc["lambda_cmd"]= lambda_cmd;

  if (!isnan(af_lambda_b1s1)) doc["af_lambda_b1s1"] = af_lambda_b1s1;

  if (!isnan(cat_b1s1_c)) doc["cat_b1s1_c"] = cat_b1s1_c;
  if (!isnan(cat_b1s2_c)) doc["cat_b1s2_c"] = cat_b1s2_c;
  if (!isnan(cat_b2s1_c)) doc["cat_b2s1_c"] = cat_b2s1_c;
  if (!isnan(cat_b2s2_c)) doc["cat_b2s2_c"] = cat_b2s2_c;

  if (!isnan(oil_temp_c))    doc["oil_temp_c"]    = oil_temp_c;
  if (!isnan(fuel_rate_lph)) doc["fuel_rate_lph"] = fuel_rate_lph;

  String payload; serializeJson(doc, payload);
  return supabasePostJson(SENSOR_PATH, payload);
}

// ---------------- Arduino entrypoints ----------------
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\nESP32 OBD-II â†’ Supabase (11b+29b, ISO-TP, extended PIDs)");

  wifiConnect();
  secureClient.setInsecure();   // dev: skip CA; for prod, pin LE R3

  // Brief listen-only sniff
  if (!canInstallStart(TWAI_MODE_LISTEN_ONLY)) {
    Serial.println("CAN LISTEN_ONLY init FAILED (check transceiver power, pins 22/21, termination)");
    while(1) delay(1000);
  }
  Serial.println("TWAI LISTEN_ONLY @ 500 kbps (sniffing briefly)");
  uint32_t t0=millis(); int sniff_rx=0;
  while (millis()-t0<LISTEN_FIRST_MS) { twai_message_t rx; if (twai_receive(&rx, pdMS_TO_TICKS(5))==ESP_OK) sniff_rx++; }
  Serial.printf("Sniff window done: frames=%d\n", sniff_rx);

  // Switch to NORMAL
  twai_stop(); twai_driver_uninstall(); delay(40);
  if (!canInitNormal()) {
    Serial.println("CAN NORMAL init FAILED (check transceiver power, pins 22/21, termination)");
    while(1) delay(1000);
  }
  Serial.println("CAN NORMAL @ 500 kbps");
}

void loop() {
  ensureWifi();

  // Keep ECUs awake
  static uint32_t lastTP=0;
  if (millis()-lastTP > 2000) { sendTesterPresent_All(); lastTP=millis(); }

  // Metrics
  float batt=NAN, coolant=NAN, rpm=NAN; long runtime_s = -1;
  float stft_b1=NAN, ltft_b1=NAN, stft_b2=NAN, ltft_b2=NAN;

  float speed_kph=NAN, speed_mph=NAN, load_pct=NAN;
  float maf_gps=NAN, map_kpa=NAN, iat_c=NAN, tps_pct=NAN;
  float baro_kpa=NAN, lambda_cmd=NAN, af_lambda_b1s1=NAN;
  float cat_b1s1_c=NAN, cat_b1s2_c=NAN, cat_b2s1_c=NAN, cat_b2s2_c=NAN;
  float oil_temp_c=NAN, fuel_rate_lph=NAN;

  static Frame buf[256];
  int idx = 0;
  int rx_count = 0;

  // FAST set (2â€“5 Hz targets)
  const uint8_t pids_fast[] = {
    0x0C, // RPM
    0x0D, // Speed
    0x05, // Coolant
    0x10, // MAF
    0x0B, // MAP
    0x0F, // IAT
    0x11, // Throttle
    0x04, // Calc Load
    0x42, // Battery
    0x06,0x07,0x08,0x09 // Trims B1/B2
  };
  for (uint8_t pid : pids_fast) {
    requestPID_sweep(pid, buf, idx, 256,
      batt,coolant,rpm,runtime_s, stft_b1,ltft_b1,stft_b2,ltft_b2,
      speed_kph,speed_mph,load_pct, maf_gps,map_kpa,iat_c,tps_pct,
      baro_kpa,lambda_cmd, af_lambda_b1s1,
      cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c, oil_temp_c,fuel_rate_lph,
      rx_count);
    delay(120);
  }

  // SLOW set (every N loops)
  static uint32_t loopCounter=0;
  if ((loopCounter % SLOW_LOOP_EVERY) == 0) {
    const uint8_t pids_slow[] = {
      0x01, // Monitor status (we don't decode here, useful for MIL/ready in future)
      0x33, // BARO
      0x44, // Commanded lambda
      0x24, // Wideband lambda B1S1 (if supported)
      0x3C,0x3D,0x3E,0x3F, // Catalyst temps
      0x52, // Oil temp (if supported)
      0x5E  // Fuel rate (if supported)
    };
    for (uint8_t pid : pids_slow) {
      requestPID_sweep(pid, buf, idx, 256,
        batt,coolant,rpm,runtime_s, stft_b1,ltft_b1,stft_b2,ltft_b2,
        speed_kph,speed_mph,load_pct, maf_gps,map_kpa,iat_c,tps_pct,
        baro_kpa,lambda_cmd, af_lambda_b1s1,
        cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c, oil_temp_c,fuel_rate_lph,
        rx_count);
      delay(150);
    }
  }
  loopCounter++;

  // Try VIN after first replies
  static bool triedVIN = false;
  if (!triedVIN && rx_count > 0 && vehicle_id == "unknown") { triedVIN = true; requestVIN(); }

  Serial.printf("VIN=%s  RX=%d  RPM=%s  Spd=%s kph  ECT=%sÂ°C  Batt=%sV  LTFT1=%s%%  LOAD=%s%%  MAF=%s g/s  MAP=%s kPa  IAT=%sÂ°C  TP=%s%%  Î»cmd=%s  Oil=%sÂ°C  Fuel=%s L/h\n",
    vehicle_id.c_str(), rx_count,
    isnan(rpm)?"-":String(rpm,0).c_str(),
    isnan(speed_kph)?"-":String(speed_kph,0).c_str(),
    isnan(coolant)?"-":String(coolant,1).c_str(),
    isnan(batt)?"-":String(batt,2).c_str(),
    isnan(ltft_b1)?"-":String(ltft_b1,1).c_str(),
    isnan(load_pct)?"-":String(load_pct,0).c_str(),
    isnan(maf_gps)?"-":String(maf_gps,1).c_str(),
    isnan(map_kpa)?"-":String(map_kpa,0).c_str(),
    isnan(iat_c)?"-":String(iat_c,1).c_str(),
    isnan(tps_pct)?"-":String(tps_pct,0).c_str(),
    isnan(lambda_cmd)?"-":String(lambda_cmd,3).c_str(),
    isnan(oil_temp_c)?"-":String(oil_temp_c,1).c_str(),
    isnan(fuel_rate_lph)?"-":String(fuel_rate_lph,2).c_str()
  );

  if (rx_count > 0) {
    bool haveParsed = (!isnan(rpm) || !isnan(coolant) || !isnan(batt) || !isnan(speed_kph) ||
                       !isnan(load_pct) || !isnan(maf_gps) || !isnan(map_kpa) || !isnan(iat_c) ||
                       !isnan(tps_pct) || !isnan(baro_kpa) || !isnan(lambda_cmd) ||
                       !isnan(af_lambda_b1s1) || !isnan(cat_b1s1_c) || !isnan(cat_b1s2_c) ||
                       !isnan(cat_b2s1_c) || !isnan(cat_b2s2_c) || !isnan(oil_temp_c) ||
                       !isnan(fuel_rate_lph) || runtime_s >= 0 ||
                       !isnan(stft_b1) || !isnan(ltft_b1) || !isnan(stft_b2) || !isnan(ltft_b2));

    if (haveParsed) {
      postSensorData(
        batt,coolant,rpm,runtime_s,
        stft_b1,ltft_b1,stft_b2,ltft_b2,
        speed_kph,speed_mph,load_pct,
        maf_gps,map_kpa,iat_c,tps_pct,
        baro_kpa,lambda_cmd,
        af_lambda_b1s1,
        cat_b1s1_c,cat_b1s2_c,cat_b2s1_c,cat_b2s2_c,
        oil_temp_c,fuel_rate_lph
      );
    }
    if (idx > 0)    postRawFramesBatch(buf, idx);
  } else {
    Serial.println("ECU appears asleep (or TX not ACKed). Skipping uploads this cycle.");
  }

  delay(1000);
}
