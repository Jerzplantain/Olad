// ===== ESP32 TWAI (CAN) + Cellular (SIM7000G) + GPS + Supabase =====
// Board: LILYGO T-SIM7000G (ESP32 + SIM7000G)
//
// Libraries (Arduino IDE ‚Üí Library Manager):
//   - TinyGSM (select SIM7000)
//   - ArduinoJson
//
// ESP32 core 2.x+ (TWAI driver present)

#include <Arduino.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "driver/twai.h"

// ---------- TinyGSM ----------
#define TINY_GSM_MODEM_SIM7000
#include <TinyGsmClient.h>

// ---------- Supabase ----------
String serverUrl    = "https://zhrlppnknfjxhwhfsdxd.supabase.co/rest/v1/sensor_data";
String rawUrl       = "https://zhrlppnknfjxhwhfsdxd.supabase.co/rest/v1/can_raw";
String SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpocmxwcG5rbmZqeGh3aGZzZHhkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1NjY3NjIsImV4cCI6MjA3MjE0Mjc2Mn0.EVrzx09YwDglwFUCjS3hKbrg2Wdy1hjSPV1gWxnN_yU";

// ---------- Device/Vehicle ----------
String vehicle_id = "NJ test facility 01";

// ---------- Status LED ----------
const int LED_PIN = 2;

// ---------- CAN pins & bitrate (avoid modem pins) ----------
const int CAN_RX_PIN = 33;   // to CAN transceiver TXD
const int CAN_TX_PIN = 32;   // to CAN transceiver RXD
const int CAN_KBPS   = 500;  // 500 kbps

// ---------- LILYGO T-SIM7000G pins ----------
static const int MODEM_PWRKEY = 4;
static const int MODEM_RST    = 5;
static const int MODEM_POWER  = 23;
static const int MODEM_RX     = 26;
static const int MODEM_TX     = 27;

// ---------- Cellular APN (Hologram) ----------
const char* APN      = "hologram";
const char* APN_USER = "";
const char* APN_PASS = "";

// ---------- Modem / clients ----------
HardwareSerial SerialAT(1);
TinyGsm modem(SerialAT);
TinyGsmClientSecure cellClient;   // HTTPS client via modem

// ================== Cellular bring-up ==================
void modemPowerOn() {
  pinMode(MODEM_POWER, OUTPUT);
  pinMode(MODEM_RST, OUTPUT);
  pinMode(MODEM_PWRKEY, OUTPUT);

  digitalWrite(MODEM_POWER, HIGH);
  delay(100);

  digitalWrite(MODEM_RST, HIGH);      // keep out of reset
  delay(100);

  // PWRKEY pulse (SIM7000 needs ~1s low)
  digitalWrite(MODEM_PWRKEY, LOW);
  delay(1100);
  digitalWrite(MODEM_PWRKEY, HIGH);
  delay(3500);
}

bool connectCellular() {
  static bool inited = false;

  if (!inited) {
    Serial.println("[CELL] Powering modem...");
    modemPowerOn();
    SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);
    delay(600);

    if (!modem.init()) {
      Serial.println("[CELL] ‚ùå modem.init() failed");
      return false;
    }
    Serial.printf("[CELL] Modem: %s\n", modem.getModemInfo().c_str());
    inited = true;
  }

  Serial.println("[CELL] Waiting for network...");
  if (!modem.waitForNetwork(180000L)) { // up to 3 minutes for first attach
    Serial.println("[CELL] ‚ùå Network not available");
    return false;
  }
  Serial.println("[CELL] ‚úÖ Registered");

  Serial.printf("[CELL] Attaching APN: %s\n", APN);
  if (!modem.gprsConnect(APN, APN_USER, APN_PASS)) {
    Serial.println("[CELL] ‚ùå APN attach failed");
    return false;
  }
  Serial.println("[CELL] ‚úÖ APN attached");

  // For development: skip CA pinning. For production, install Supabase CA with setCACert().
  cellClient.setInsecure();
  return true;
}

bool ensureCell() {
  if (modem.isGprsConnected()) return true;
  return connectCellular();
}

// ================== HTTPS POST (cellular only) ==================
bool postJson(const String& url, const String& jsonPayload) {
  if (!ensureCell()) {
    Serial.println("[HTTP] No cellular connection");
    return false;
  }

  HTTPClient http;
  if (!http.begin(cellClient, url)) {
    Serial.println("[HTTP] begin() failed");
    return false;
  }

  http.addHeader("Content-Type", "application/json");
  http.addHeader("apikey", SUPABASE_KEY);
  http.addHeader("Authorization", "Bearer " + SUPABASE_KEY);

  int status = http.POST(jsonPayload);
  bool ok = (status >= 200 && status < 300);
  Serial.printf("[HTTP] %s (%d)\n", ok ? "OK" : "FAIL", status);
  http.end();

  if (!ok) {
    // Attempt one reconnect cycle if POST failed
    modem.gprsDisconnect();
    delay(1000);
    connectCellular();
  }
  return ok;
}

// ================== Supabase payloads ==================
void sendData(float battery_voltage, float coolant_temp, float rpm, float speed,
              bool hasGps, double lat, double lon, float alt, float spd_kph, int sats, const String& gps_time) {
  if (!ensureCell()) return;

  StaticJsonDocument<768> doc;
  doc["vehicle_id"] = vehicle_id;
  if (battery_voltage >= 0) doc["battery_voltage"]     = battery_voltage;
  if (coolant_temp   >= 0) doc["coolant_temperature"] = coolant_temp;
  if (rpm            >= 0) doc["engine_rpms"]         = rpm;
  if (speed          >= 0) doc["speed"]               = speed;

  if (hasGps) {
    JsonObject gps = doc.createNestedObject("gps");
    gps["lat"]       = lat;
    gps["lon"]       = lon;
    gps["alt_m"]     = alt;
    gps["speed_kph"] = spd_kph;
    gps["sats"]      = sats;
    gps["time_utc"]  = gps_time; // e.g. "2025-10-05T14:23:11Z"
  }

  String payload;
  serializeJson(doc, payload);
  bool ok = postJson(serverUrl, payload);
  Serial.printf("üì° PID/GPS Upload %s\n", ok ? "OK" : "FAIL");
}

void sendRawFrame(int packetId, bool isExt, const uint8_t *buf, int len) {
  if (!ensureCell()) return;

  StaticJsonDocument<320> doc;
  doc["vehicle_id"]   = vehicle_id;
  doc["can_id"]       = packetId;
  doc["is_extended"]  = isExt;

  JsonArray dataArr = doc.createNestedArray("data");
  for (int i = 0; i < len; i++) dataArr.add(buf[i]);

  String payload;
  serializeJson(doc, payload);
  bool ok = postJson(rawUrl, payload);
  Serial.printf("üì° RAW Upload %s\n", ok ? "OK" : "FAIL");
}

// ================== TWAI (CAN) helpers ==================
bool twai_init(uint32_t bitrate_kbps, int rx, int tx) {
  twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT((gpio_num_t)rx, (gpio_num_t)tx, TWAI_MODE_NORMAL);

  twai_timing_config_t t_config;
  switch (bitrate_kbps) {
    case 125:  t_config = TWAI_TIMING_CONFIG_125KBITS(); break;
    case 250:  t_config = TWAI_TIMING_CONFIG_250KBITS(); break;
    case 500:  t_config = TWAI_TIMING_CONFIG_500KBITS(); break;
    case 800:  t_config = TWAI_TIMING_CONFIG_800KBITS(); break;
    case 1000: t_config = TWAI_TIMING_CONFIG_1MBITS();   break;
    default:   t_config = TWAI_TIMING_CONFIG_500KBITS(); break;
  }

  twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();

  if (twai_driver_install(&g_config, &t_config, &f_config) != ESP_OK) {
    Serial.println("‚ùå twai_driver_install failed");
    return false;
  }
  if (twai_start() != ESP_OK) {
    Serial.println("‚ùå twai_start failed");
    return false;
  }

  Serial.println("‚úÖ TWAI (CAN) driver started");
  return true;
}

void requestPID(uint8_t pid, bool extended = false) {
  twai_message_t msg = {};
  msg.extd = extended ? 1 : 0;
  msg.rtr  = 0;
  msg.ss   = 0;
  msg.self = 0;
  msg.data_length_code = 8;

  msg.identifier = extended ? 0x18DB33F1 : 0x7DF; // functional request

  msg.data[0] = 0x02; // single-frame len
  msg.data[1] = 0x01; // mode 01 current data
  msg.data[2] = pid;
  for (int i = 3; i < 8; i++) msg.data[i] = 0x00;

  if (twai_transmit(&msg, pdMS_TO_TICKS(20)) == ESP_OK) {
    Serial.printf("üì§ Sent %s PID 0x%02X\n", extended ? "EXT" : "STD", pid);
  } else {
    Serial.println("‚ùå twai_transmit failed");
  }
}

float parseResponse(int packetId, bool extended, const uint8_t *buf, int len, uint8_t pid) {
  // Typical: [len] [0x41] [PID] [A] [B] ...
  bool idMatch = (!extended && packetId == 0x7E8) || (extended && packetId == 0x18DAF110);
  if (idMatch && len >= 5 && buf[1] == 0x41 && buf[2] == pid) {
    switch (pid) {
      case 0x0C: return ((buf[3] * 256) + buf[4]) / 4.0;    // RPM
      case 0x05: return buf[3] - 40;                        // Coolant ¬∞C
      case 0x0D: return buf[3];                             // Speed (km/h)
      case 0x42: return ((buf[3] * 256) + buf[4]) / 1000.0; // Control module V
    }
  }
  return -1;
}

// ================== GPS helpers (SIM7000G) ==================
bool gpsOn = false;

bool ensureGpsOn() {
  if (!gpsOn) {
    if (!modem.enableGPS()) {
      Serial.println("[GPS] ‚ùå enableGPS failed");
      return false;
    }
    gpsOn = true;
    Serial.println("[GPS] ‚úÖ GPS enabled");
  }
  return true;
}

bool readGps(double &lat, double &lon, float &alt, float &spd_kph, int &sats, String &isoUtc) {
  if (!ensureCell()) return false; // modem must be up
  if (!ensureGpsOn()) return false;

  for (int i = 0; i < 10; i++) {
    if (modem.getGPS(&lat, &lon, &alt, &spd_kph, &sats)) {
      int year, month, day, hour, minute, second;
      if (modem.getGPSTime(&year, &month, &day, &hour, &minute, &second)) {
        char buf[25];
        snprintf(buf, sizeof(buf), "%04d-%02d-%02dT%02d:%02d:%02dZ",
                 year, month, day, hour, minute, second);
        isoUtc = String(buf);
      } else {
        isoUtc = "";
      }
      return true;
    }
    delay(500);
  }
  return false;
}

// ================== Setup ==================
void setup() {
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  // Bring up cellular
  if (!ensureCell()) {
    Serial.println("üö´ Cellular failed to start. Retrying in 5s...");
    delay(5000);
  }

  // Start TWAI (CAN)
  if (!twai_init(CAN_KBPS, CAN_RX_PIN, CAN_TX_PIN)) {
    Serial.println("‚ùå Starting TWAI failed!");
    while (1) { delay(1000); }
  }
}

// ================== Loop ==================
void loop() {
  // 1) Request PIDs (std + ext)
  requestPID(0x0C, false); // RPM
  requestPID(0x05, false); // Coolant
  requestPID(0x0D, false); // Speed
  requestPID(0x42, false); // Control module voltage
  requestPID(0x0C, true);
  requestPID(0x05, true);
  requestPID(0x0D, true);
  requestPID(0x42, true);

  delay(120);

  // 2) Read CAN responses for a short window
  float rpm = -1, coolant = -1, speed = -1, batt = -1;
  const uint32_t window_ms = 500;
  uint32_t t0 = millis();

  while (millis() - t0 < window_ms) {
    twai_message_t rx_msg;
    if (twai_receive(&rx_msg, pdMS_TO_TICKS(10)) == ESP_OK) {
      int packetId = rx_msg.identifier;
      bool isExt   = rx_msg.extd;
      int len      = rx_msg.data_length_code;

      Serial.printf("‚¨áÔ∏è RX %s ID: 0x%X LEN: %d Data:", isExt ? "EXT" : "STD", packetId, len);
      for (int i = 0; i < len; i++) Serial.printf(" %02X", rx_msg.data[i]);
      Serial.println();

      bool decoded = false;
      float val;
      val = parseResponse(packetId, isExt, rx_msg.data, len, 0x0C); if (val >= 0) { rpm     = val; decoded = true; }
      val = parseResponse(packetId, isExt, rx_msg.data, len, 0x05); if (val >= 0) { coolant = val; decoded = true; }
      val = parseResponse(packetId, isExt, rx_msg.data, len, 0x0D); if (val >= 0) { speed   = val; decoded = true; }
      val = parseResponse(packetId, isExt, rx_msg.data, len, 0x42); if (val >= 0) { batt    = val; decoded = true; }

      if (!decoded) sendRawFrame(packetId, isExt, rx_msg.data, len);
    }
  }

  // 3) GPS (via modem)
  bool hasGps = false;
  double lat=0, lon=0;
  float alt=0, spd_kph=0;
  int sats=0;
  String gps_time="";

  hasGps = readGps(lat, lon, alt, spd_kph, sats, gps_time);
  if (hasGps) {
    Serial.printf("[GPS] Fix lat=%.6f lon=%.6f alt=%.1f m spd=%.1f kph sats=%d time=%s\n",
                  lat, lon, alt, spd_kph, sats, gps_time.c_str());
  } else {
    Serial.println("[GPS] No fix yet");
  }

  // 4) Upload decoded PIDs (+ GPS if present)
  if (rpm >= 0 || coolant >= 0 || speed >= 0 || batt >= 0 || hasGps) {
    sendData(batt, coolant, rpm, speed, hasGps, lat, lon, alt, spd_kph, sats, gps_time);
  }

  delay(2000);
}
]
