// ==== ESP32 OBD-II → Supabase (VIN fallbacks: Serial/NVS + Supabase config; mph only) ====
// CAN: GPIO22=CTX, GPIO21=CRX, 500 kbit/s

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <Preferences.h>
#include "driver/twai.h"
#include <math.h>
#include <ctype.h>

// ---------- EDIT ----------
const char* WIFI_SSID = "YOUR_WIFI";
const char* WIFI_PASS = "YOUR_PASS";

// Identify this device (used for cloud VIN fetch)
const char* DEVICE_ID = "esp32-van-01";

// Supabase (host+path for SNI)
const char* SUPABASE_HOST = "zhrlppnknfjxhwhfsdxd.supabase.co";
const char* SENSOR_PATH   = "/rest/v1/sensor_data";
const char* RAW_PATH      = "/rest/v1/can_raw";
const char* DEVICES_PATH  = "/rest/v1/devices"; // optional cloud VIN
String SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpocmxwcG5rbmZqeGh3aGZzZHhkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1NjY3NjIsImV4cCI6MjA3MjE0Mjc2Mn0.EVrzx09YwDglwFUCjS3hKbrg2Wdy1hjSPV1gWxnN_yU";

// VIN becomes vehicle_id
String vehicle_id = "unknown";

// CAN pins
#define TWAI_TX_PIN GPIO_NUM_22
#define TWAI_RX_PIN GPIO_NUM_21

// Raw post batching
#define RAW_CHUNK_SIZE 32

struct Frame { uint32_t ts,id; uint8_t dlc,data[8]; bool is_ext; };

WiFiClientSecure secureClient; HTTPClient http;
Preferences prefs;

// ====== Address lists ======
static const uint16_t PHYS11_REQ_IDS[] = {0x7E0,0x7E1,0x7E2,0x7E3,0x7E4,0x7E5,0x7E6,0x7E7};
static const uint8_t  TARGETS29[] = {
  0x10,0x11,0x12,0x17,0x18,
  0x20,0x22,0x24,0x26,0x28,0x2C,
  0x34,0x37,0x3B,0x3E,
  0x40,0x42,0x44,0x4B,
  0x50,0x52,0x58,
  0x60,0x62,0x64,0x6A,
  0x70
};
#define REQ29(t)  (0x18DAF100u | (uint32_t)(t))
#define RESP29(t) (0x18DA0000u | ((uint32_t)(t)<<8) | 0xF1u)

// ====== Helpers ======
static bool wifiConnect(){
  WiFi.mode(WIFI_STA); WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi");
  uint32_t t0=millis();
  while(WiFi.status()!=WL_CONNECTED && millis()-t0<20000){ delay(300); Serial.print("."); }
  Serial.println();
  if(WiFi.status()==WL_CONNECTED){
    Serial.printf("WiFi OK %s RSSI=%d\n", WiFi.localIP().toString().c_str(), WiFi.RSSI());
    return true;
  }
  Serial.println("WiFi FAIL"); return false;
}
static void ensureWifi(){ if (WiFi.status()!=WL_CONNECTED) wifiConnect(); }

static bool canInitNormal(){
  twai_general_config_t g = TWAI_GENERAL_CONFIG_DEFAULT(TWAI_TX_PIN, TWAI_RX_PIN, TWAI_MODE_NORMAL);
  twai_timing_config_t  t = TWAI_TIMING_CONFIG_500KBITS();
  twai_filter_config_t  f = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  if (twai_driver_install(&g,&t,&f)!=ESP_OK) return false;
  if (twai_start()!=ESP_OK) return false;
  return true;
}
static void pushFromMsg(Frame& dst, const twai_message_t& m){
  dst.ts=millis(); dst.is_ext=(m.flags & TWAI_MSG_FLAG_EXTD);
  dst.id = dst.is_ext? m.identifier : (m.identifier & 0x7FF);
  dst.dlc=m.data_length_code;
  for(int i=0;i<dst.dlc && i<8;i++) dst.data[i]=m.data[i];
}
static bool canSend(uint32_t id, bool is_ext, const uint8_t* data, uint8_t dlc){
  twai_message_t tx={}; tx.identifier=id; tx.flags=is_ext?TWAI_MSG_FLAG_EXTD:TWAI_MSG_FLAG_NONE;
  tx.data_length_code=dlc; for(int i=0;i<dlc && i<8;i++) tx.data[i]=data[i];
  return twai_transmit(&tx, pdMS_TO_TICKS(50))==ESP_OK;
}

// ====== Supabase HTTP ======
static bool httpBegin(HTTPClient& cli, const char* host, const char* path){
  return cli.begin(secureClient, host, 443, path, true);
}
static void addCommonHeaders(HTTPClient& h){
  h.addHeader("apikey", SUPABASE_KEY);
  h.addHeader("Authorization","Bearer "+SUPABASE_KEY);
}
static bool supabasePostJson(const char* path, const String& payload){
  ensureWifi();
  if(!httpBegin(http, SUPABASE_HOST, path)){ Serial.println("HTTP begin failed"); return false; }
  http.setTimeout(15000); secureClient.setTimeout(15000);
  http.addHeader("Content-Type","application/json");
  addCommonHeaders(http);
  http.addHeader("Prefer","return=minimal");
  int code=http.POST((uint8_t*)payload.c_str(), payload.length());
  String resp=http.getString();
  Serial.printf("POST %d to https://%s%s\n", code, SUPABASE_HOST, path);
  if (code<200 || code>=300){ Serial.println(resp); http.end(); return false; }
  http.end(); return true;
}
static bool supabaseGet(const String& path_with_query, String& bodyOut){
  ensureWifi();
  if(!httpBegin(http, SUPABASE_HOST, path_with_query.c_str())){ Serial.println("HTTP begin failed"); return false; }
  http.setTimeout(15000); secureClient.setTimeout(15000);
  addCommonHeaders(http);
  int code=http.GET();
  bodyOut = http.getString();
  Serial.printf("GET %d from https://%s%s\n", code, SUPABASE_HOST, path_with_query.c_str());
  http.end();
  return (code>=200 && code<300);
}
static String toHex(const uint8_t* data, uint8_t len){
  char b[3]; String s; for(uint8_t i=0;i<len;i++){ if(i) s+=' '; snprintf(b,sizeof(b),"%02X",data[i]); s+=b; } return s;
}
static bool postRawFramesBatch(const Frame* frames,int count){
  int sent=0;
  while(sent<count){
    int n=min(RAW_CHUNK_SIZE, count-sent);
    StaticJsonDocument<4096> doc; JsonArray arr=doc.to<JsonArray>();
    for(int i=0;i<n;i++){
      const Frame& fr=frames[sent+i];
      JsonObject r=arr.createNestedObject();
      r["vehicle_id"]=vehicle_id; r["vin"]=vehicle_id;
      r["can_id"]=(int)fr.id; r["is_ext"]=fr.is_ext; r["dlc"]=(int)fr.dlc;
      r["data_hex"]=toHex(fr.data, fr.dlc); r["ts_ms"]=(long long)fr.ts;
    }
    String payload; serializeJson(doc,payload);
    if(!supabasePostJson(RAW_PATH,payload)) return false;
    sent+=n;
  }
  return true;
}
static bool postSensorData(float batt,float coolant,float rpm,float speed_mph,
                           float stft_b1,float ltft_b1,float stft_b2,float ltft_b2,
                           long runtime_s)
{
  StaticJsonDocument<768> doc;
  doc["vehicle_id"]=vehicle_id; doc["vin"]=vehicle_id;
  if(!isnan(speed_mph)) doc["speed_mph"]=speed_mph;
  if(!isnan(batt))      doc["batt"]=batt;
  if(!isnan(coolant))   doc["coolant"]=coolant;
  if(!isnan(rpm))       doc["rpm"]=rpm;
  if(!isnan(stft_b1))   doc["stft_b1"]=stft_b1;
  if(!isnan(ltft_b1))   doc["ltft_b1"]=ltft_b1;
  if(!isnan(stft_b2))   doc["stft_b2"]=stft_b2;
  if(!isnan(ltft_b2))   doc["ltft_b2"]=ltft_b2;
  if(runtime_s>=0)      doc["runtime_s"]=runtime_s;
  String payload; serializeJson(doc,payload);
  return supabasePostJson(SENSOR_PATH,payload);
}

// ====== OBD decoders ======
static float decodeTemp(uint8_t A){ return (float)A - 40.0f; }
static float decodeRPM(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/4.0f; }
static float decodeVoltage(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/1000.0f; }
static float decodeTrim(uint8_t A){ return ((float)A - 128.0f)*100.0f/128.0f; }
static long  decodeU16(uint8_t A,uint8_t B){ return (long)(A*256 + B); }
static float decodeSpeedMPH(uint8_t A){ return ((float)A)*0.621371f; }

// ====== VIN scan (still there, but gateway may block) ======
static Frame scanBuf[64]; static int scanIdx=0;
static void logScanFrame(const twai_message_t& rx){
  if(scanIdx>= (int)(sizeof(scanBuf)/sizeof(scanBuf[0]))) return;
  pushFromMsg(scanBuf[scanIdx], rx); scanIdx++;
}
static void flushScanBuf(){ if(scanIdx>0){ postRawFramesBatch(scanBuf, scanIdx); scanIdx=0; } }

static bool sendFC(uint32_t req_id, bool is_ext){ uint8_t fc[8]={0x30,0x00,0x00,0,0,0,0,0}; return canSend(req_id,is_ext,fc,8); }

// Generic ISO-TP request/collect; returns raw payload (PCI stripped).
static bool isoTpRequestCollect(uint32_t req_id, uint32_t resp_id, bool is_ext,
                                const uint8_t* req, uint8_t req_len,
                                uint8_t* out, int& out_len, int max_len)
{
  uint8_t buf[8]={0}; for(uint8_t i=0;i<req_len && i<8;i++) buf[i]=req[i];
  if(!canSend(req_id,is_ext,buf,8)) return false;

  out_len=0; int total_len=-1; bool gotFF=false;
  uint32_t t0=millis();
  while(millis()-t0<2000){  // longer wait
    twai_message_t rx; if(twai_receive(&rx,pdMS_TO_TICKS(40))!=ESP_OK) continue;
    logScanFrame(rx);
    if(rx.identifier!=resp_id) continue;
    bool rx_ext=(rx.flags & TWAI_MSG_FLAG_EXTD); if(rx_ext!=is_ext) continue;
    const uint8_t* d=rx.data; uint8_t dlc=rx.data_length_code;

    if(dlc>=3 && d[1]==0x7F){ Serial.printf("UDS NACK: 7F %02X %02X (id 0x%X)\n", d[2], d[3], rx.identifier); }

    uint8_t pci=d[0]&0xF0;
    if(pci==0x00){ // Single
      int len=d[0]&0x0F; for(int i=1;i<dlc && out_len<max_len && (i-1)<len;i++) out[out_len++]=d[i];
      return out_len>0;
    } else if(pci==0x10 && dlc>=2){ // First
      total_len=((d[0]&0x0F)<<8)|d[1];
      for(int i=2;i<dlc && out_len<max_len;i++) out[out_len++]=d[i];
      sendFC(req_id,is_ext);
      gotFF=true; break;
    }
  }
  if(!gotFF) return out_len>0;

  uint32_t t1=millis();
  while(millis()-t1<4000 && (total_len<0 || out_len<total_len)){
    twai_message_t rx; if(twai_receive(&rx,pdMS_TO_TICKS(40))!=ESP_OK) continue;
    logScanFrame(rx);
    if(rx.identifier!=resp_id) continue;
    bool rx_ext=(rx.flags & TWAI_MSG_FLAG_EXTD); if(rx_ext!=is_ext) continue;
    const uint8_t* d=rx.data; uint8_t dlc=rx.data_length_code;
    if((d[0]&0xF0)==0x20 && dlc>=2){
      for(int i=1;i<dlc && out_len<max_len;i++) out[out_len++]=d[i];
      if(total_len>0 && out_len>=total_len) break;
    }
  }
  return out_len>0;
}

static String parseVINFromPayload(const uint8_t* p, int n){
  auto ascii_ok=[](uint8_t c){ return (c>=32 && c<=126); };
  String vin;
  // UDS 62 F1 90
  for(int i=0;i+3<=n;i++){
    if(p[i]==0x62 && p[i+1]==0xF1 && p[i+2]==0x90){
      int j=i+3; while(j<n && (int)vin.length()<17){ uint8_t c=p[j++]; if(c && c!=0xFF && ascii_ok(c) && c!=' ') vin+=(char)c; }
      if(vin.length()>=11) return vin.substring(0, min(17, (int)vin.length()));
      vin=""; break;
    }
  }
  // OBD 49 02
  for(int i=0;i+3<=n;i++){
    if(p[i]==0x49 && p[i+1]==0x02){
      int j=i+3; while(j<n && (int)vin.length()<17){
        if(j+2<n && p[j]==0x49 && p[j+1]==0x02) break;
        uint8_t c=p[j++]; if(c && c!=0xFF && ascii_ok(c) && c!=' ') vin+=(char)c;
      }
      if(vin.length()>=17) break;
    }
  }
  if(vin.length()>17) vin=vin.substring(0,17);
  if(vin.length()>=11) return vin;
  return String();
}

static String isoTpVIN_OBD(uint32_t req_id,uint32_t resp_id,bool is_ext){
  uint8_t req[3]={0x02,0x09,0x02}; uint8_t out[128]; int len=0;
  if(!isoTpRequestCollect(req_id,resp_id,is_ext,req,3,out,len,sizeof(out))) return String();
  return parseVINFromPayload(out,len);
}
static String isoTpVIN_UDS(uint32_t req_id,uint32_t resp_id,bool is_ext){
  uint8_t req[3]={0x22,0xF1,0x90}; uint8_t out[128]; int len=0;
  if(!isoTpRequestCollect(req_id,resp_id,is_ext,req,3,out,len,sizeof(out))) return String();
  return parseVINFromPayload(out,len);
}

static void tryVINScan(){
  // 11-bit functional sniff (best effort) skipped—gateway likely blocks
  // 11-bit physical scan
  for (uint8_t i=0;i<sizeof(PHYS11_REQ_IDS)/sizeof(PHYS11_REQ_IDS[0]);i++){
    uint32_t req = PHYS11_REQ_IDS[i], rsp = req+0x8;
    String vin = isoTpVIN_OBD(req, rsp, false); if(vin.length()>=11){ vehicle_id=vin; return; }
    vin = isoTpVIN_UDS(req, rsp, false);        if(vin.length()>=11){ vehicle_id=vin; return; }
  }
  // 29-bit physical scan
  for(uint8_t i=0;i<sizeof(TARGETS29);i++){
    uint8_t t = TARGETS29[i];
    uint32_t req = REQ29(t), rsp = RESP29(t);
    String vin = isoTpVIN_OBD(req, rsp, true); if(vin.length()>=11){ vehicle_id=vin; return; }
    vin = isoTpVIN_UDS(req, rsp, true);        if(vin.length()>=11){ vehicle_id=vin; return; }
  }
  flushScanBuf();
}

// ====== VIN fallbacks ======
static bool isLikelyVIN(const String& s){
  if(s.length()<11 || s.length()>20) return false; // accept 17 normally
  for(size_t i=0;i<s.length();i++){
    char c=s[i];
    if(!( (c>='0'&&c<='9') || (c>='A'&&c<='Z') )) return false;
    if(c=='I'||c=='O'||c=='Q') return false; // VIN never uses I,O,Q
  }
  return true;
}
static void saveVINToNVS(const String& vin){
  prefs.begin("veh", false);
  prefs.putString("vin", vin);
  prefs.end();
  Serial.printf("💾 Saved VIN to NVS: %s\n", vin.c_str());
}
static bool loadVINFromNVS(){
  prefs.begin("veh", true);
  String vin = prefs.getString("vin", "");
  prefs.end();
  if(isLikelyVIN(vin)){ vehicle_id=vin; Serial.printf("🔁 VIN from NVS: %s\n", vehicle_id.c_str()); return true; }
  return false;
}
static bool fetchVINFromSupabase(){
  // GET /rest/v1/devices?device_id=eq.<DEVICE_ID>&select=vin&limit=1
  String path = String(DEVICES_PATH) + "?device_id=eq." + DEVICE_ID + "&select=vin&limit=1";
  String body;
  if(!supabaseGet(path, body)) return false;
  DynamicJsonDocument doc(1024);
  DeserializationError err = deserializeJson(doc, body);
  if(err){ Serial.println("JSON parse error (devices)"); return false; }
  if(!doc.is<JsonArray>() || doc.as<JsonArray>().size()==0) return false;
  String vin = doc[0]["vin"] | "";
  vin.trim(); vin.toUpperCase();
  if(isLikelyVIN(vin)){ vehicle_id=vin; Serial.printf("☁ VIN from Supabase devices: %s\n", vehicle_id.c_str()); saveVINToNVS(vehicle_id); return true; }
  return false;
}
static void serialVINConsole(){
  // Accept lines like: vin=1HGCM82633A123456
  static String line;
  while(Serial.available()){
    char c=Serial.read();
    if(c=='\n' || c=='\r'){
      line.trim();
      if(line.startsWith("vin=") || line.startsWith("VIN=")){
        String v=line.substring(4); v.trim(); v.toUpperCase();
        if(isLikelyVIN(v)){ vehicle_id=v; saveVINToNVS(vehicle_id); Serial.printf("✅ VIN set from Serial: %s\n", vehicle_id.c_str()); }
        else { Serial.println("⚠ Invalid VIN format"); }
      }
      line="";
    } else if(line.length()<64){ line+=c; }
  }
}

// ====== PID poller ======
static void requestPID(uint8_t pid, Frame* out, int& idx, int max,
                       float& batt,float& coolant,float& rpm,float& speed_mph,
                       float& stft_b1,float& ltft_b1,float& stft_b2,float& ltft_b2,
                       long& runtime_s,int& rx_count)
{
  if(idx>=max) return;
  uint8_t req[8]={0x02,0x01,pid,0,0,0,0,0};
  if(!canSend(0x7DF,false,req,8)){ Serial.printf("TX fail PID 0x%02X\n",pid); return; }
  Serial.printf("📤 PID 0x%02X @0x7DF\n", pid);

  uint32_t t0=millis();
  while(millis()-t0<60 && idx<max){
    twai_message_t rx;
    if(twai_receive(&rx,pdMS_TO_TICKS(5))==ESP_OK){
      Frame f; pushFromMsg(f,rx); out[idx++]=f; rx_count++;
      if(rx.data_length_code>=3 && rx.data[1]==0x41 && rx.data[2]==pid){
        uint8_t A=(rx.data_length_code>3)?rx.data[3]:0;
        uint8_t B=(rx.data_length_code>4)?rx.data[4]:0;
        switch(pid){
          case 0x05: coolant=decodeTemp(A); break;
          case 0x0C: rpm=decodeRPM(A,B); break;
          case 0x0D: speed_mph=decodeSpeedMPH(A); break;
          case 0x42: batt=decodeVoltage(A,B); break;
          case 0x1F: runtime_s=decodeU16(A,B); break;
          case 0x06: stft_b1=decodeTrim(A); break;
          case 0x07: ltft_b1=decodeTrim(A); break;
          case 0x08: stft_b2=decodeTrim(A); break;
          case 0x09: ltft_b2=decodeTrim(A); break;
        }
      }
    }
  }
}

// ====== Arduino ======
void setup(){
  Serial.begin(115200); delay(200);
  Serial.println("\nESP32 OBD-II → Supabase (VIN fallbacks + mph)");
  wifiConnect(); secureClient.setInsecure();
  if(!canInitNormal()){ Serial.println("CAN init FAILED"); while(1) delay(1000); }
  Serial.println("CAN NORMAL @ 500 kbps");

  // 1) Load VIN from NVS (if previously set)
  if(loadVINFromNVS()) return;

  // 2) Try cloud config (devices table)
  fetchVINFromSupabase(); // ok if this fails; we still run without VIN
}

void loop(){
  serialVINConsole();   // allow typing vin=... any time
  ensureWifi();

  float batt=NAN,coolant=NAN,rpm=NAN,speed_mph=NAN;
  float stft_b1=NAN,ltft_b1=NAN,stft_b2=NAN,ltft_b2=NAN;
  long runtime_s=-1;

  static Frame buf[128]; int idx=0; int rx_count=0;

  const uint8_t pids[]={0x0C,0x0D,0x05,0x42,0x1F,0x06,0x07,0x08,0x09};
  for(uint8_t pid: pids){
    requestPID(pid,buf,idx,128,batt,coolant,rpm,speed_mph,stft_b1,ltft_b1,stft_b2,ltft_b2,runtime_s,rx_count);
    delay(20);
  }

  // If we still don't have VIN and ECUs are awake, try one VIN scan (once)
  static bool triedVINScan=false;
  if(!triedVINScan && rx_count>0 && vehicle_id=="unknown"){
    triedVINScan=true;
    Serial.println("🔎 VIN scan (gateway may block)...");
    tryVINScan();
    if(isLikelyVIN(vehicle_id)) saveVINToNVS(vehicle_id);
  }

  Serial.printf("VIN=%s RX=%d Speed=%.0f mph RPM=%.0f Coolant=%.1f°C Batt=%.2fV Runtime=%lds\n",
    vehicle_id.c_str(), rx_count, speed_mph, rpm, coolant, batt, runtime_s);

  bool haveParsed = (!isnan(speed_mph)||!isnan(rpm)||!isnan(coolant)||!isnan(batt)||
                     runtime_s>=0||!isnan(stft_b1)||!isnan(ltft_b1)||!isnan(stft_b2)||!isnan(ltft_b2));
  if(rx_count>0){
    if(haveParsed) postSensorData(batt,coolant,rpm,speed_mph,stft_b1,ltft_b1,stft_b2,ltft_b2,runtime_s);
    if(idx>0) postRawFramesBatch(buf,idx);
  } else {
    Serial.println("ECU asleep/no replies; skipping upload.");
  }

  delay(1000);
}


