// ==== ESP32 OBD-II PID poller → Supabase (VIN fix: ISO-TP FC + 29-bit fallback, mph only) ====
// CAN pins: GPIO22 -> CTX, GPIO21 -> CRX  |  Bus: 500 kbps (OBD-II)

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "driver/twai.h"
#include <math.h>
#include <ctype.h>

// ---------- EDIT (Wi-Fi) ----------
const char* WIFI_SSID = "YOUR_WIFI";
const char* WIFI_PASS = "YOUR_PASS";

// ===== Supabase (host+path for SNI reliability) =====
const char* SUPABASE_HOST = "zhrlppnknfjxhwhfsdxd.supabase.co";
const char* SENSOR_PATH   = "/rest/v1/sensor_data";   // parsed readings
const char* RAW_PATH      = "/rest/v1/can_raw";       // raw frames
String SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpocmxwcG5rbmZqeGh3aGZzZHhkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1NjY3NjIsImV4cCI6MjA3MjE0Mjc2Mn0.EVrzx09YwDglwFUCjS3hKbrg2Wdy1hjSPV1gWxnN_yU";

// VIN becomes our vehicle_id once detected
String vehicle_id = "unknown";

// ---- CAN pins ----
#define TWAI_TX_PIN GPIO_NUM_22
#define TWAI_RX_PIN GPIO_NUM_21

// Reduce memory spikes when posting raw frames
#define RAW_CHUNK_SIZE 32

struct Frame {
  uint32_t ts;
  uint32_t id;
  uint8_t  dlc;
  uint8_t  data[8];
  bool     is_ext;
};

WiFiClientSecure secureClient;
HTTPClient http;

// ---------------- Wi-Fi helpers ----------------
static bool wifiConnect() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi");
  uint32_t t0 = millis();
  while (WiFi.status()!=WL_CONNECTED && millis()-t0<20000) { delay(300); Serial.print("."); }
  Serial.println();
  if (WiFi.status()==WL_CONNECTED) {
    Serial.printf("WiFi OK, IP: %s  RSSI=%d dBm\n", WiFi.localIP().toString().c_str(), WiFi.RSSI());
    return true;
  }
  Serial.println("WiFi FAILED");
  return false;
}
static void ensureWifi() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi dropped — reconnecting...");
    wifiConnect();
  }
}

// ---------------- CAN/TWAI ----------------
static bool canInitNormal() {
  twai_general_config_t g = TWAI_GENERAL_CONFIG_DEFAULT(TWAI_TX_PIN, TWAI_RX_PIN, TWAI_MODE_NORMAL);
  twai_timing_config_t  t = TWAI_TIMING_CONFIG_500KBITS();   // OBD-II 500k
  twai_filter_config_t  f = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  if (twai_driver_install(&g, &t, &f) != ESP_OK) return false;
  if (twai_start() != ESP_OK) return false;
  return true;
}
static void pushFromMsg(Frame& dst, const twai_message_t& m) {
  dst.ts  = millis();
  bool ext = (m.flags & TWAI_MSG_FLAG_EXTD);
  dst.id  = ext ? m.identifier : (m.identifier & 0x7FF);
  dst.is_ext = ext;
  dst.dlc = m.data_length_code;
  for (int i=0;i<dst.dlc && i<8;i++) dst.data[i] = m.data[i];
}
static bool canSend(uint32_t id, bool is_ext, const uint8_t* data, uint8_t dlc) {
  twai_message_t tx = {};
  tx.identifier = id;
  tx.flags = is_ext ? TWAI_MSG_FLAG_EXTD : TWAI_MSG_FLAG_NONE;
  tx.data_length_code = dlc;
  for (int i=0;i<dlc && i<8;i++) tx.data[i] = data[i];
  return (twai_transmit(&tx, pdMS_TO_TICKS(50)) == ESP_OK);
}

// ---------------- Supabase (HTTPS) ----------------
static bool httpBeginHostPath(HTTPClient& cli, const char* host, const char* path) {
  return cli.begin(secureClient, host, 443, path, true); // https + SNI
}
static bool supabasePostJson(const char* path, const String& payload) {
  ensureWifi();
  if (!httpBeginHostPath(http, SUPABASE_HOST, path)) {
    Serial.println("HTTP begin failed");
    return false;
  }
  http.setTimeout(15000);
  secureClient.setTimeout(15000);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("apikey", SUPABASE_KEY);
  http.addHeader("Authorization", "Bearer " + SUPABASE_KEY);
  http.addHeader("Prefer", "return=minimal");
  int code = http.POST((uint8_t*)payload.c_str(), payload.length());
  String resp = http.getString();
  Serial.printf("POST %d to https://%s%s\n", code, SUPABASE_HOST, path);
  if (code < 200 || code >= 300) {
    Serial.println(resp);
    http.end();
    return false;
  }
  http.end();
  return true;
}

// ---------------- Posting helpers ----------------
static bool postSensorData(
  float batt, float coolant, float rpm, float speed_mph,
  float stft_b1, float ltft_b1, float stft_b2, float ltft_b2,
  long runtime_s
) {
  StaticJsonDocument<640> doc;
  doc["vehicle_id"] = vehicle_id;      // VIN
  doc["vin"]        = vehicle_id;

  if (!isnan(speed_mph)) doc["speed_mph"] = speed_mph;
  if (!isnan(batt))      doc["batt"]      = batt;
  if (!isnan(coolant))   doc["coolant"]   = coolant;
  if (!isnan(rpm))       doc["rpm"]       = rpm;
  if (!isnan(stft_b1))   doc["stft_b1"]   = stft_b1;
  if (!isnan(ltft_b1))   doc["ltft_b1"]   = ltft_b1;
  if (!isnan(stft_b2))   doc["stft_b2"]   = stft_b2;
  if (!isnan(ltft_b2))   doc["ltft_b2"]   = ltft_b2;
  if (runtime_s >= 0)    doc["runtime_s"] = runtime_s;

  String payload; serializeJson(doc, payload);
  return supabasePostJson(SENSOR_PATH, payload);
}
static String toHexBytes(const uint8_t* data, uint8_t len) {
  char buf[3];
  String s;
  for (uint8_t i=0;i<len;i++) {
    if (i) s += ' ';
    snprintf(buf, sizeof(buf), "%02X", data[i]);
    s += buf;
  }
  return s;
}
static bool postRawFramesBatch(const Frame* frames, int count) {
  int sent = 0;
  while (sent < count) {
    int n = min(RAW_CHUNK_SIZE, count - sent);
    StaticJsonDocument<4096> doc;
    JsonArray arr = doc.to<JsonArray>();
    for (int i=0;i<n;i++) {
      const Frame& fr = frames[sent + i];
      JsonObject r = arr.createNestedObject();
      r["vehicle_id"] = vehicle_id;
      r["vin"]        = vehicle_id;
      r["can_id"]     = (int)fr.id;
      r["is_ext"]     = fr.is_ext;
      r["dlc"]        = (int)fr.dlc;
      r["data_hex"]   = toHexBytes(fr.data, fr.dlc);
      r["ts_ms"]      = (long long)fr.ts;
    }
    String payload; serializeJson(doc, payload);
    bool ok = supabasePostJson(RAW_PATH, payload);
    if (!ok) return false;
    sent += n;
  }
  return true;
}

// ---------------- OBD decoders ----------------
static float decodeTemp(uint8_t A){ return (float)A - 40.0f; }
static float decodeRPM(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/4.0f; }
static float decodeVoltage(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/1000.0f; }
static float decodeTrim(uint8_t A){ return ((float)A - 128.0f) * 100.0f / 128.0f; }
static long  decodeU16(uint8_t A,uint8_t B){ return (long)(A*256 + B); }
static float decodeSpeedMPH(uint8_t A){ return ((float)A) * 0.621371f; } // PID 0x0D km/h -> mph

// ---------------- VIN helpers (ISO-TP + fallbacks) ----------------
static bool sendFlowControl(uint32_t req_id, bool is_ext) {
  // ISO-TP FC: 0x30 (Continue To Send), block size=0, STmin=0
  uint8_t fc[8] = {0x30, 0x00, 0x00, 0,0,0,0,0};
  return canSend(req_id, is_ext, fc, 8);
}

// ISO-TP multi-frame *physical* read for VIN (Mode 09 PID 02)
static String isoTpReadVINPhysical(uint32_t req_id, uint32_t resp_id, bool is_ext) {
  uint8_t req[8] = {0x02, 0x09, 0x02, 0,0,0,0,0};
  if (!canSend(req_id, is_ext, req, 8)) return String();

  uint8_t payload[96]; int plen=0; bool gotFF=false, done=false;
  uint32_t t0 = millis();
  while (millis()-t0 < 150) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(20)) != ESP_OK) continue;
    if (rx.identifier != resp_id) continue;
    bool rx_ext = (rx.flags & TWAI_MSG_FLAG_EXTD);
    if (rx_ext != is_ext) continue;

    const uint8_t* d = rx.data; uint8_t dlc = rx.data_length_code;
    if (dlc < 3) continue;

    // Single Frame
    if ( (d[0] & 0xF0) == 0x00 ) {
      int len = (d[0] & 0x0F);
      for (int i=1;i<dlc && plen < (int)sizeof(payload) && (i-1)<len;i++) payload[plen++] = d[i];
      done = true;
      break;
    }

    // First Frame
    if ( (d[0] & 0xF0) == 0x10 && dlc >= 6 ) {
      gotFF = true;
      for (int i=2;i<dlc && plen < (int)sizeof(payload); i++) payload[plen++] = d[i];
      sendFlowControl(req_id, is_ext);
      break;
    }
  }
  if (!gotFF && !done) return String();

  // Consecutive Frames
  if (gotFF) {
    uint32_t t1 = millis();
    while (millis()-t1 < 600 && plen < (int)sizeof(payload)) {
      twai_message_t rx;
      if (twai_receive(&rx, pdMS_TO_TICKS(25)) != ESP_OK) continue;
      if (rx.identifier != resp_id) continue;
      bool rx_ext = (rx.flags & TWAI_MSG_FLAG_EXTD);
      if (rx_ext != is_ext) continue;

      const uint8_t* d = rx.data; uint8_t dlc = rx.data_length_code;
      if ((d[0] & 0xF0) == 0x20 && dlc >= 2) {
        for (int i=1;i<dlc && plen < (int)sizeof(payload); i++) payload[plen++] = d[i];
        if (plen >= 24) break; // enough for 17 ASCII VIN (+header)
      }
    }
  }

  // Parse payload for 49 02 01 ... ASCII VIN
  String vin;
  for (int i=0;i<plen; i++) {
    if (i+3 <= plen && payload[i]==0x49 && payload[i+1]==0x02) {
      int j = i+3;
      while (j < plen && (int)vin.length() < 17) {
        char c = (char)payload[j++];
        if (c>=' ' && c<='~' && c!=' ') vin += c;
      }
      break;
    }
  }
  if (vin.length() > 17) vin = vin.substring(0,17);
  if (vin.length() >= 11) return vin;
  return String();
}

// Functional (0x7DF) best-effort: some ECUs reply 49 02 01/02/03 as singles
static String functionalReadVIN11bit() {
  uint8_t req[8] = {0x02,0x09,0x02,0,0,0,0,0};
  if (!canSend(0x7DF, false, req, 8)) return String();
  char partBuf[3][8]; uint8_t partLen[3]={0,0,0}; bool got[3]={0,0,0};
  uint32_t t0=millis();
  while (millis()-t0 < 400) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(20)) != ESP_OK) continue;
    if ((rx.flags & TWAI_MSG_FLAG_EXTD)) continue; // std only
    const uint8_t* d = rx.data; uint8_t dlc = rx.data_length_code;
    if (dlc >= 4 && d[1]==0x49 && d[2]==0x02) {
      uint8_t p = d[3]; if (p>=1 && p<=3) {
        uint8_t idx=p-1, start=4, len=(dlc>start)?(dlc-start):0; if (len>7) len=7;
        for (uint8_t i=0;i<len;i++) partBuf[idx][i]=(char)d[start+i];
        partLen[idx]=len; got[idx]=true;
      }
    }
  }
  String vin;
  for (int p=0;p<3;p++) if (got[p]) for (int i=0;i<partLen[p];i++) if (partBuf[p][i]!=' ') vin += partBuf[p][i];
  if (vin.length()>17) vin = vin.substring(0,17);
  if (vin.length()>=11) return vin;
  return String();
}

// Master VIN routine: functional 11-bit → physical 11-bit (FC) → physical 29-bit (FC)
static void requestVIN() {
  // 1) 11-bit functional
  {
    Serial.println("📤 VIN try: functional 11-bit (0x7DF)");
    String vin = functionalReadVIN11bit();
    if (vin.length()>=11) { vehicle_id=vin; Serial.printf("✅ VIN (functional): %s\n", vehicle_id.c_str()); return; }
  }
  // 2) 11-bit physical with ISO-TP FC (req 0x7E0, resp 0x7E8)
  {
    Serial.println("📤 VIN try: physical 11-bit (0x7E0→0x7E8) + FC");
    String vin = isoTpReadVINPhysical(0x7E0, 0x7E8, false);
    if (vin.length()>=11) { vehicle_id=vin; Serial.printf("✅ VIN (11-bit phys): %s\n", vehicle_id.c_str()); return; }
  }
  // 3) 29-bit physical with ISO-TP FC (req 0x18DAF110, resp 0x18DA10F1)
  {
    Serial.println("📤 VIN try: physical 29-bit (0x18DAF110→0x18DA10F1) + FC");
    String vin = isoTpReadVINPhysical(0x18DAF110, 0x18DA10F1, true);
    if (vin.length()>=11) { vehicle_id=vin; Serial.printf("✅ VIN (29-bit phys): %s\n", vehicle_id.c_str()); return; }
  }
  Serial.println("⚠ VIN not found, using 'unknown'");
}

// ---------------- PID request/parse (RX-only buffer) ----------------
static void requestPID(uint8_t pid, Frame* out, int& idx, int max,
                       float& batt, float& coolant, float& rpm, float& speed_mph,
                       float& stft_b1, float& ltft_b1, float& stft_b2, float& ltft_b2,
                       long& runtime_s, int& rx_count)
{
  if (idx >= max) return;
  uint8_t req[8] = {0x02,0x01,pid,0,0,0,0,0};
  if (!canSend(0x7DF, false, req, 8)) { Serial.printf("TX failed for PID 0x%02X\n", pid); return; }
  Serial.printf("📤 Sent STD PID 0x%02X on ID 0x7DF\n", pid);

  // Collect responses (~60 ms)
  uint32_t t0 = millis();
  while (millis() - t0 < 60 && idx < max) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(5)) == ESP_OK) {
      Frame f; pushFromMsg(f, rx);
      out[idx++] = f;         // RX only
      rx_count++;             // ECUs are awake

      if ((rx.data_length_code >= 3) && rx.data[1] == 0x41 && rx.data[2] == pid) {
        uint8_t A = (rx.data_length_code > 3) ? rx.data[3] : 0;
        uint8_t B = (rx.data_length_code > 4) ? rx.data[4] : 0;
        switch (pid) {
          case 0x05: coolant   = decodeTemp(A);           break;
          case 0x0C: rpm       = decodeRPM(A,B);          break;
          case 0x0D: speed_mph = decodeSpeedMPH(A);       break;
          case 0x42: batt      = decodeVoltage(A,B);      break;
          case 0x1F: runtime_s = decodeU16(A,B);          break;
          case 0x06: stft_b1   = decodeTrim(A);           break;
          case 0x07: ltft_b1   = decodeTrim(A);           break;
          case 0x08: stft_b2   = decodeTrim(A);           break;
          case 0x09: ltft_b2   = decodeTrim(A);           break;
        }
      }
    }
  }
}

// ---------------- Arduino entrypoints ----------------
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\nESP32 OBD-II → Supabase (VIN fix + mph)");

  wifiConnect();
  secureClient.setInsecure();   // dev: skip CA; for prod, pin Let's Encrypt R3

  if (!canInitNormal()) {
    Serial.println("CAN init FAILED (check transceiver power, pins 22/21, termination)");
    while(1) delay(1000);
  }
  Serial.println("CAN NORMAL @ 500 kbps");
}

void loop() {
  ensureWifi();

  // Metrics (start as NaN / -1)
  float batt=NAN, coolant=NAN, rpm=NAN, speed_mph=NAN;
  float stft_b1=NAN, ltft_b1=NAN, stft_b2=NAN, ltft_b2=NAN;
  long runtime_s = -1;

  static Frame buf[128];
  int idx = 0;
  int rx_count = 0;

  // Query PIDs (includes 0x0D speed)
  const uint8_t pids[] = {0x0C,0x0D,0x05,0x42,0x1F,0x06,0x07,0x08,0x09};
  for (uint8_t pid : pids) {
    requestPID(pid, buf, idx, 128, batt, coolant, rpm, speed_mph,
               stft_b1, ltft_b1, stft_b2, ltft_b2, runtime_s, rx_count);
    delay(20);
  }

  Serial.printf("VIN=%s  RX=%d  Speed=%.0f mph  RPM=%.0f  Coolant=%.1f°C  Batt=%.2fV  Runtime=%lds  STFT1=%.1f%%  LTFT1=%.1f%%  STFT2=%.1f%%  LTFT2=%.1f%%\n",
    vehicle_id.c_str(), rx_count, speed_mph, rpm, coolant, batt, runtime_s, stft_b1, ltft_b1, stft_b2, ltft_b2);

  // Try VIN once ECUs are awake (do this once)
  static bool triedVIN = false;
  if (!triedVIN && rx_count > 0 && vehicle_id == "unknown") {
    triedVIN = true;
    requestVIN();
  }

  // Upload only if we got replies (ignition ON)
  if (rx_count > 0) {
    bool haveParsed = (!isnan(speed_mph) || !isnan(rpm) || !isnan(coolant) || !isnan(batt) ||
                       runtime_s >= 0 || !isnan(stft_b1) || !isnan(ltft_b1) ||
                       !isnan(stft_b2) || !isnan(ltft_b2));

    if (haveParsed) {
      postSensorData(batt, coolant, rpm, speed_mph,
                     stft_b1, ltft_b1, stft_b2, ltft_b2, runtime_s);
    }
    if (idx > 0) {
      postRawFramesBatch(buf, idx);  // RX-only frames
    }
  } else {
    Serial.println("ECU appears asleep (vehicle OFF). Skipping uploads this cycle.");
  }

  delay(1000); // ~1 Hz
}

