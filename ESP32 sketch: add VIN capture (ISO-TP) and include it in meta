// ==== ESP32 OBD-II poller + VIN (Mode09 PID02) + Firestore ingest ====
// Pins: GPIO22 -> CTX, GPIO21 -> CRX
// Secret: "american"  |  URL: your ingestCan endpoint

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "driver/twai.h"
#include <ctype.h>

// ------------ EDIT ------------
const char* WIFI_SSID     = "YOUR_WIFI";
const char* WIFI_PASS     = "YOUR_PASS";
const char* FUNC_URL      = "https://us-central1-olads-guardian.cloudfunctions.net/ingestCan";
const char* DEVICE_SECRET = "american";
const char* DEVICE_ID     = "esp32-van-01";

#define TWAI_TX_PIN GPIO_NUM_22
#define TWAI_RX_PIN GPIO_NUM_21

struct Frame { uint32_t ts, id; uint8_t dlc; uint8_t data[8]; };

static char   gVIN[18] = {0};
static bool   gHaveVIN = false;

// ------------ Wi-Fi ------------
static bool wifiConnect() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi");
  uint32_t t0 = millis();
  while (WiFi.status()!=WL_CONNECTED && millis()-t0<20000){ delay(300); Serial.print("."); }
  Serial.println();
  if (WiFi.status()==WL_CONNECTED){ Serial.printf("WiFi OK, IP: %s\n", WiFi.localIP().toString().c_str()); return true; }
  Serial.println("WiFi FAILED"); return false;
}

// ------------ CAN init (NORMAL @500k) ------------
static bool canInitNormal() {
  twai_general_config_t g = TWAI_GENERAL_CONFIG_DEFAULT(TWAI_TX_PIN, TWAI_RX_PIN, TWAI_MODE_NORMAL);
  twai_timing_config_t  t = TWAI_TIMING_CONFIG_500KBITS();
  twai_filter_config_t  f = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  if (twai_driver_install(&g, &t, &f) != ESP_OK) return false;
  if (twai_start() != ESP_OK) return false;
  return true;
}

static void pushFromMsg(Frame& dst, const twai_message_t& m) {
  dst.ts  = millis();
  dst.id  = (m.flags & TWAI_MSG_FLAG_EXTD) ? m.identifier : (m.identifier & 0x7FF);
  dst.dlc = m.data_length_code;
  for (int i=0;i<dst.dlc && i<8;i++) dst.data[i] = m.data[i];
}

// ------------ HTTP upload with meta (adds VIN if known) ------------
static bool sendBatchWithMeta(const Frame* frames, int count,
                              float batt, float coolant, float rpm,
                              float stft_b1, float ltft_b1, float stft_b2, float ltft_b2,
                              long runtime_s)
{
  WiFiClientSecure client; client.setInsecure();
  HTTPClient http;
  if (!http.begin(client, FUNC_URL)) { Serial.println("HTTP begin failed"); return false; }
  http.addHeader("Content-Type", "application/json");
  http.addHeader("x-device-secret", DEVICE_SECRET);

  StaticJsonDocument<8192> doc;
  doc["device_id"] = DEVICE_ID;

  JsonObject meta = doc.createNestedObject("meta");
  if (gHaveVIN)     meta["vin"]       = gVIN;
  if (!isnan(batt)) meta["battery_v"] = batt;
  if (!isnan(coolant)) meta["coolant_c"] = coolant;
  if (!isnan(rpm))  meta["rpm"]       = rpm;
  if (!isnan(stft_b1)) meta["stft_b1"] = stft_b1;
  if (!isnan(ltft_b1)) meta["ltft_b1"] = ltft_b1;
  if (!isnan(stft_b2)) meta["stft_b2"] = stft_b2;
  if (!isnan(ltft_b2)) meta["ltft_b2"] = ltft_b2;
  if (runtime_s >= 0) meta["runtime_s"] = runtime_s;

  JsonArray arr = doc.createNestedArray("frames");
  for (int i=0;i<count;i++) {
    JsonObject f = arr.createNestedObject();
    f["ts"]  = frames[i].ts;
    f["id"]  = frames[i].id;
    f["dlc"] = frames[i].dlc;
    JsonArray d = f.createNestedArray("data");
    for (int b=0;b<frames[i].dlc;b++) d.add(frames[i].data[b]);
  }

  String payload; serializeJson(doc, payload);
  int code = http.POST((uint8_t*)payload.c_str(), payload.length());
  String resp = http.getString();
  Serial.printf("POST %d\n", code);
  if (code != 200) Serial.println(resp);
  http.end();
  return code==200;
}

// ------------ OBD decodes (as before) ------------
static float decodeTemp(uint8_t A){ return (float)A - 40.0f; }
static float decodeRPM(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/4.0f; }
static float decodeVoltage(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/1000.0f; }
static float decodeTrim(uint8_t A){ return ((float)A - 128.0f) * 100.0f / 128.0f; }
static long  decodeU16(uint8_t A,uint8_t B){ return (long)(A*256 + B); }

// ------------ VIN fetch (Mode 09 PID 02, ISO-TP) ------------
static bool fetchVIN(char* outVIN, size_t outLen, uint32_t overallMs = 800) {
  if (!outVIN || outLen < 18) return false;
  outVIN[0] = 0;

  // Send physical request to 0x7E0: 02 09 02 00 00 00 00 00
  twai_message_t req = {};
  req.identifier = 0x7E0;
  req.flags = TWAI_MSG_FLAG_NONE;
  req.data_length_code = 8;
  req.data[0] = 0x02; req.data[1] = 0x09; req.data[2] = 0x02;
  for (int i=3;i<8;i++) req.data[i] = 0x00;

  if (twai_transmit(&req, pdMS_TO_TICKS(50)) != ESP_OK) {
    Serial.println("VIN TX failed");
    return false;
  }

  // Buffer to assemble ISO-TP payload
  uint8_t payload[64]; int plen = 0; int need = -1;
  uint32_t t0 = millis();

  while (millis() - t0 < overallMs) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(50)) != ESP_OK) continue;
    if ((rx.identifier & 0x7F8) != 0x7E8) continue; // from ECU

    uint8_t pci = rx.data[0] & 0xF0;
    if (pci == 0x00) {
      // Single frame (unlikely for VIN, but handle)
      int len = rx.data[0] & 0x0F;
      int copy = min(len, 7);
      memcpy(payload, &rx.data[1], copy);
      plen = copy;
      need = len;
      break;
    } else if (pci == 0x10) {
      // First frame
      need = ((rx.data[0] & 0x0F) << 8) | rx.data[1]; // total payload length
      int copy = min(6, need);
      memcpy(payload, &rx.data[2], copy);
      plen = copy;

      // Send Flow Control (CTS) to 0x7E0
      twai_message_t fc = {};
      fc.identifier = 0x7E0;
      fc.flags = TWAI_MSG_FLAG_NONE;
      fc.data_length_code = 8;
      fc.data[0] = 0x30; // FC CTS
      fc.data[1] = 0x00; // Block size: unlimited
      fc.data[2] = 0x00; // STmin
      for (int i=3;i<8;i++) fc.data[i]=0x00;
      twai_transmit(&fc, pdMS_TO_TICKS(50));
    } else if (pci == 0x20 && need > 0) {
      // Consecutive frame
      int copy = min(7, need - plen);
      memcpy(payload + plen, &rx.data[1], copy);
      plen += copy;
      if (plen >= need) break;
    }
  }

  if (need <= 0 || plen <= 0) {
    Serial.println("VIN not received");
    return false;
  }

  // Payload should contain blocks like: 49 02 01 <VIN...>, 49 02 02..., 49 02 03...
  char vin[18] = {0};
  int vlen = 0;
  for (int i=0; i<plen && vlen<17; ) {
    if (i+2 < plen && payload[i]==0x49 && payload[i+1]==0x02) {
      int j = i+3; // data bytes after 49 02 <rec#>
      while (j < plen && vlen < 17) {
        uint8_t b = payload[j++];
        if (b==0x00) continue;
        if (b >= 0x20 && b <= 0x7E) vin[vlen++] = (char)b;
      }
      // move to next potential block header
      i += 3;
    } else {
      i++;
    }
  }
  if (vlen == 17) {
    memcpy(outVIN, vin, 18);
    Serial.printf("ðŸ“Ž VIN: %s\n", outVIN);
    return true;
  } else {
    Serial.printf("VIN parse incomplete (got %d chars)\n", vlen);
    return false;
  }
}

// ------------ Request one PID and collect responses ------------
static void requestPID(uint8_t pid, Frame* out, int& idx, int max,
                       float& batt, float& coolant, float& rpm,
                       float& stft_b1, float& ltft_b1, float& stft_b2, float& ltft_b2,
                       long& runtime_s)
{
  if (idx >= max) return;

  twai_message_t tx = {};
  tx.identifier = 0x7DF;               // functional request
  tx.flags = TWAI_MSG_FLAG_NONE;
  tx.data_length_code = 8;
  tx.data[0] = 0x02; tx.data[1] = 0x01; tx.data[2] = pid;
  for (int i=3;i<8;i++) tx.data[i]=0x00;

  if (twai_transmit(&tx, pdMS_TO_TICKS(50)) == ESP_OK) {
    Frame f; pushFromMsg(f, tx);
    if (idx < max) out[idx++] = f;
  } else {
    Serial.printf("TX failed PID 0x%02X\n", pid);
    return;
  }

  // Responses 0x7E8..0x7EF within ~60ms
  uint32_t t0 = millis();
  while (millis() - t0 < 60 && idx < max) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(5)) == ESP_OK) {
      Frame f; pushFromMsg(f, rx);
      out[idx++] = f;

      if (rx.data_length_code >= 4 && rx.data[1] == 0x41 && rx.data[2] == pid) {
        uint8_t A = rx.data[3], B = rx.data_length_code>4?rx.data[4]:0, C = rx.data_length_code>5?rx.data[5]:0, D = rx.data_length_code>6?rx.data[6]:0;
        switch (pid) {
          case 0x05: coolant = decodeTemp(A); break;
          case 0x0C: rpm     = decodeRPM(A,B); break;
          case 0x42: batt    = decodeVoltage(A,B); break;
          case 0x1F: runtime_s = decodeU16(A,B); break;
          case 0x06: stft_b1 = decodeTrim(A); break;
          case 0x07: ltft_b1 = decodeTrim(A); break;
          case 0x08: stft_b2 = decodeTrim(A); break;
          case 0x09: ltft_b2 = decodeTrim(A); break;
        }
      }
    }
  }
}

void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\nOLADS OBD-II poller + VIN â†’ Firestore");
  Serial.println(FUNC_URL);

  wifiConnect();

  if (!canInitNormal()) {
    Serial.println("CAN init FAILED (check voltage, pins 22/21, RS/EN low, 500k, termination)");
    while(1) delay(1000);
  }
  Serial.println("CAN NORMAL @ 500 kbps");

  // Try VIN once at startup (will also retry in loop until found)
  if (fetchVIN(gVIN, sizeof(gVIN))) gHaveVIN = true;
}

void loop() {
  // If VIN not captured yet, retry occasionally
  static uint32_t lastVIN = 0;
  if (!gHaveVIN && millis() - lastVIN > 5000) {
    if (fetchVIN(gVIN, sizeof(gVIN))) gHaveVIN = true;
    lastVIN = millis();
  }

  // Gather & send normal PIDs
  float batt=NAN, coolant=NAN, rpm=NAN, stft_b1=NAN, ltft_b1=NAN, stft_b2=NAN, ltft_b2=NAN;
  long runtime_s = -1;

  static Frame buf[128];
  int idx = 0;
  const uint8_t pids[] = {0x0C,0x05,0x42,0x1F,0x06,0x07,0x08,0x09};
  for (uint8_t pid : pids) { requestPID(pid, buf, idx, 128, batt, coolant, rpm, stft_b1, ltft_b1, stft_b2, ltft_b2, runtime_s); delay(20); }

  Serial.printf("VIN=%s  RPM=%.0f  Coolant=%.1fÂ°C  Batt=%.2fV\n",
                gHaveVIN?gVIN:"(pending)", rpm, coolant, batt);

  if (idx>0) sendBatchWithMeta(buf, idx, batt, coolant, rpm, stft_b1, ltft_b1, stft_b2, ltft_b2, runtime_s);

  delay(1000);
}
