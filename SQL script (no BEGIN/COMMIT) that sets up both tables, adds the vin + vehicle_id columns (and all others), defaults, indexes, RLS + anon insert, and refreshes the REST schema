-- =========================
-- Base tables (create if missing)
-- =========================
create table if not exists public.sensor_data (
  id bigint generated always as identity primary key
);

create table if not exists public.can_raw (
  id bigint generated always as identity primary key
);

-- =========================
-- sensor_data: columns + defaults
-- =========================
alter table public.sensor_data add column if not exists vin         text;
alter table public.sensor_data add column if not exists vehicle_id  text;
alter table public.sensor_data add column if not exists speed_mph   real;          -- mph only
alter table public.sensor_data add column if not exists batt        real;
alter table public.sensor_data add column if not exists coolant     real;
alter table public.sensor_data add column if not exists rpm         real;
alter table public.sensor_data add column if not exists stft_b1     real;
alter table public.sensor_data add column if not exists ltft_b1     real;
alter table public.sensor_data add column if not exists stft_b2     real;
alter table public.sensor_data add column if not exists ltft_b2     real;
alter table public.sensor_data add column if not exists runtime_s   integer;
alter table public.sensor_data add column if not exists "timestamp" timestamptz default now();

update public.sensor_data
   set "timestamp" = now()
 where "timestamp" is null;

alter table public.sensor_data alter column "timestamp" set not null;

-- Optional: default vehicle_id for legacy rows
update public.sensor_data
   set vehicle_id = coalesce(vehicle_id, 'unknown')
 where vehicle_id is null;

-- =========================
-- can_raw: columns + defaults
-- =========================
alter table public.can_raw add column if not exists vin         text;
alter table public.can_raw add column if not exists vehicle_id  text;
alter table public.can_raw add column if not exists can_id      integer;
alter table public.can_raw add column if not exists is_ext      boolean default false;
alter table public.can_raw add column if not exists dlc         smallint;
alter table public.can_raw add column if not exists data_hex    text;
alter table public.can_raw add column if not exists ts_ms       bigint;
alter table public.can_raw add column if not exists created_at  timestamptz default now();

update public.can_raw
   set created_at = now()
 where created_at is null;

alter table public.can_raw alter column created_at set not null;

-- =========================
-- Indexes
-- =========================
create index if not exists sensor_data_vin_time_idx
  on public.sensor_data (vin, "timestamp" desc);

create index if not exists sensor_data_vehicle_time_idx
  on public.sensor_data (vehicle_id, "timestamp" desc);

create index if not exists can_raw_vin_time_idx
  on public.can_raw (vin, created_at desc);

create index if not exists can_raw_vehicle_time_idx
  on public.can_raw (vehicle_id, created_at desc);

-- =========================
-- RLS: enable + allow inserts from anon (device posts with anon key)
-- =========================
alter table public.sensor_data enable row level security;
alter table public.can_raw    enable row level security;

drop policy if exists sensor_data_insert_anon on public.sensor_data;
create policy sensor_data_insert_anon
  on public.sensor_data
  for insert
  to anon
  with check (true);

drop policy if exists can_raw_insert_anon on public.can_raw;
create policy can_raw_insert_anon
  on public.can_raw
  for insert
  to anon
  with check (true);

-- (Optional) If you want client-side reads via anon, uncomment:
-- drop policy if exists sensor_data_select_anon on public.sensor_data;
-- create policy sensor_data_select_anon on public.sensor_data for select to anon using (true);
-- drop policy if exists can_raw_select_anon on public.can_raw;
-- create policy can_raw_select_anon on public.can_raw for select to anon using (true);

-- =========================
-- Latest snapshot view (1 row per VIN; includes mph)
-- =========================
create or replace view public.v_latest_sensor as
select distinct on (vin)
  vin,
  vehicle_id,
  speed_mph,
  batt, coolant, rpm,
  stft_b1, ltft_b1, stft_b2, ltft_b2,
  runtime_s,
  "timestamp"
from public.sensor_data
where vin is not null and vin <> ''
order by vin, "timestamp" desc;

-- =========================
-- Daily rollup (mph) as materialized view
-- =========================
drop materialized view if exists public.mv_sensor_daily;

create materialized view public.mv_sensor_daily as
select
  vin,
  date_trunc('day', "timestamp")::date as day,
  avg(speed_mph)  as avg_speed_mph,
  max(speed_mph)  as max_speed_mph,
  avg(batt)       as avg_batt,
  avg(rpm)        as avg_rpm,
  max(coolant)    as max_coolant,
  avg(stft_b1)    as avg_stft_b1,
  avg(ltft_b1)    as avg_ltft_b1,
  avg(stft_b2)    as avg_stft_b2,
  avg(ltft_b2)    as avg_ltft_b2,
  count(*)        as samples
from public.sensor_data
where vin is not null and vin <> ''
group by 1,2;

-- Unique index (enables CONCURRENT refresh)
create unique index if not exists mv_sensor_daily_uniq
  on public.mv_sensor_daily (vin, day);

-- Handy lookup index
create index if not exists mv_sensor_daily_vin_day_idx
  on public.mv_sensor_daily (vin, day desc);

-- Initial build
refresh materialized view public.mv_sensor_daily;

-- (Optional) Auto-refresh every 5 minutes via pg_cron
create extension if not exists pg_cron;
select cron.unschedule('refresh_mv_sensor_daily_5min')
where exists (select 1 from cron.job where jobname='refresh_mv_sensor_daily_5min');

select cron.schedule(
  'refresh_mv_sensor_daily_5min',
  '*/5 * * * *',
  $$ refresh materialized view concurrently public.mv_sensor_daily; $$
);

-- =========================
-- REST schema cache reload (fixes "schema cache" stale errors)
-- =========================
select pg_notify('pgrst','reload schema');
