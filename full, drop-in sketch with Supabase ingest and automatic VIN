// ==== ESP32 OBD-II PID poller â†’ Supabase (ignition-aware uploads) ====
// Pins: GPIO22 -> CTX, GPIO21 -> CRX

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "driver/twai.h"
#include <math.h>
#include <ctype.h>

// ---------- EDIT (Wi-Fi) ----------
const char* WIFI_SSID = "iPhone";
const char* WIFI_PASS = "american";

// ===== Supabase host + paths (host+path form improves TLS/SNI reliability) =====
const char* SUPABASE_HOST = "zhrlppnknfjxhwhfsdxd.supabase.co";
const char* SENSOR_PATH   = "/rest/v1/sensor_data";   // parsed PIDs
const char* RAW_PATH      = "/rest/v1/can_raw";       // raw frames
String SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpocmxwcG5rbmZqeGh3aGZzZHhkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1NjY3NjIsImV4cCI6MjA3MjE0Mjc2Mn0.EVrzx09YwDglwFUCjS3hKbrg2Wdy1hjSPV1gWxnN_yU";

// Will be set from Mode 09 PID 02 (VIN) once ECUs are awake:
String vehicle_id = "unknown";

// ---- CAN pins ----
#define TWAI_TX_PIN GPIO_NUM_22
#define TWAI_RX_PIN GPIO_NUM_21

// Reduce memory spikes when posting raw frames
#define RAW_CHUNK_SIZE 32

struct Frame {
  uint32_t ts;
  uint32_t id;
  uint8_t  dlc;
  uint8_t  data[8];
  bool     is_ext;
};

WiFiClientSecure secureClient;
HTTPClient http;

// ---------------- Util / Debug ----------------
static bool wifiConnect() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi");
  uint32_t t0 = millis();
  while (WiFi.status()!=WL_CONNECTED && millis()-t0<20000) { delay(300); Serial.print("."); }
  Serial.println();
  if (WiFi.status()==WL_CONNECTED) {
    Serial.printf("WiFi OK, IP: %s  RSSI=%d dBm\n", WiFi.localIP().toString().c_str(), WiFi.RSSI());
    return true;
  }
  Serial.println("WiFi FAILED");
  return false;
}

static void ensureWifi() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi dropped â€” reconnecting...");
    wifiConnect();
  }
}

// ---------------- CAN/TWAI ----------------
static bool canInitNormal() {
  twai_general_config_t g = TWAI_GENERAL_CONFIG_DEFAULT(TWAI_TX_PIN, TWAI_RX_PIN, TWAI_MODE_NORMAL);
  twai_timing_config_t  t = TWAI_TIMING_CONFIG_500KBITS();   // OBD-II 500k
  twai_filter_config_t  f = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  if (twai_driver_install(&g, &t, &f) != ESP_OK) return false;
  if (twai_start() != ESP_OK) return false;
  return true;
}

static void pushFromMsg(Frame& dst, const twai_message_t& m) {
  dst.ts  = millis();
  bool ext = (m.flags & TWAI_MSG_FLAG_EXTD);
  dst.id  = ext ? m.identifier : (m.identifier & 0x7FF);
  dst.is_ext = ext;
  dst.dlc = m.data_length_code;
  for (int i=0;i<dst.dlc && i<8;i++) dst.data[i] = m.data[i];
}

// ---------------- Supabase helpers (SNI-safe begin) ----------------
static bool httpBeginHostPath(HTTPClient& cli, const char* host, const char* path) {
  return cli.begin(secureClient, host, 443, path, true); // https + SNI
}

static bool supabasePostJson(const char* path, const String& payload) {
  ensureWifi();
  if (!httpBeginHostPath(http, SUPABASE_HOST, path)) {
    Serial.println("HTTP begin failed");
    return false;
  }
  http.setTimeout(15000);
  secureClient.setTimeout(15000);

  http.addHeader("Content-Type", "application/json");
  http.addHeader("apikey", SUPABASE_KEY);
  http.addHeader("Authorization", "Bearer " + SUPABASE_KEY);
  http.addHeader("Prefer", "return=minimal");

  int code = http.POST((uint8_t*)payload.c_str(), payload.length());
  String resp = http.getString();
  Serial.printf("POST %d to https://%s%s\n", code, SUPABASE_HOST, path);
  if (code < 200 || code >= 300) {
    Serial.println(resp);
    http.end();
    return false;
  }
  http.end();
  return true;
}

// Post one parsed sensor row to public.sensor_data
static bool postSensorData(
  float batt, float coolant, float rpm,
  float stft_b1, float ltft_b1, float stft_b2, float ltft_b2,
  long runtime_s
) {
  StaticJsonDocument<512> doc;
  doc["vehicle_id"] = vehicle_id;
  if (!isnan(batt))      doc["batt"]      = batt;
  if (!isnan(coolant))   doc["coolant"]   = coolant;
  if (!isnan(rpm))       doc["rpm"]       = rpm;
  if (!isnan(stft_b1))   doc["stft_b1"]   = stft_b1;
  if (!isnan(ltft_b1))   doc["ltft_b1"]   = ltft_b1;
  if (!isnan(stft_b2))   doc["stft_b2"]   = stft_b2;
  if (!isnan(ltft_b2))   doc["ltft_b2"]   = ltft_b2;
  if (runtime_s >= 0)    doc["runtime_s"] = runtime_s;

  String payload; serializeJson(doc, payload);
  return supabasePostJson(SENSOR_PATH, payload);
}

static String toHexBytes(const uint8_t* data, uint8_t len) {
  char buf[3];
  String s;
  for (uint8_t i=0;i<len;i++) {
    if (i) s += ' ';
    snprintf(buf, sizeof(buf), "%02X", data[i]);
    s += buf;
  }
  return s;
}

// Batch-post raw frames to public.can_raw in smaller chunks (saves heap)
static bool postRawFramesBatch(const Frame* frames, int count) {
  int sent = 0;
  while (sent < count) {
    int n = min(RAW_CHUNK_SIZE, count - sent);
    StaticJsonDocument<4096> doc;
    JsonArray arr = doc.to<JsonArray>();
    for (int i=0;i<n;i++) {
      const Frame& fr = frames[sent + i];
      JsonObject r = arr.createNestedObject();
      r["vehicle_id"] = vehicle_id;
      r["can_id"]     = (int)fr.id;
      r["is_ext"]     = fr.is_ext;
      r["dlc"]        = (int)fr.dlc;
      r["data_hex"]   = toHexBytes(fr.data, fr.dlc);
      r["ts_ms"]      = (long long)fr.ts;
    }
    String payload; serializeJson(doc, payload);
    bool ok = supabasePostJson(RAW_PATH, payload);
    if (!ok) return false;
    sent += n;
  }
  return true;
}

// ---------------- OBD-II decoders ----------------
static float decodeTemp(uint8_t A){ return (float)A - 40.0f; }                     // PID 05 (Â°C)
static float decodeRPM(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/4.0f; }         // PID 0C (rpm)
static float decodeVoltage(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/1000.0f; }  // PID 42 (V)
static float decodeTrim(uint8_t A){ return ((float)A - 128.0f) * 100.0f / 128.0f; }// 06â€“09 (%)
static long  decodeU16(uint8_t A,uint8_t B){ return (long)(A*256 + B); }           // PID 1F (s)

// ---------------- VIN (Mode 09 PID 02) ----------------
// Handles ISO-TP multi-frame and 49 02 01/02/03 replies
static void requestVIN() {
  twai_message_t tx = {};
  tx.identifier = 0x7DF;
  tx.flags = TWAI_MSG_FLAG_NONE;   // 11-bit
  tx.data_length_code = 8;
  tx.data[0] = 0x02;               // 2 data bytes
  tx.data[1] = 0x09;               // Service 09
  tx.data[2] = 0x02;               // PID 02 = VIN
  tx.data[3] = tx.data[4] = tx.data[5] = tx.data[6] = tx.data[7] = 0x00;

  if (twai_transmit(&tx, pdMS_TO_TICKS(50)) == ESP_OK) {
    Serial.println("ðŸ“¤ Sent request for VIN (09 02)");
  } else {
    Serial.println("TX failed for VIN");
    return;
  }

  char vinbuf[32]; uint8_t vinlen = 0;
  char partBuf[3][8]; uint8_t partLen[3] = {0,0,0}; bool gotPart[3] = {false,false,false};
  bool sawISOTP = false;

  uint32_t t0 = millis();
  while (millis() - t0 < 1200) {  // give ECUs time to stream
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(20)) != ESP_OK) continue;
    const uint8_t *d = rx.data;
    uint8_t dlc = rx.data_length_code;
    if (dlc < 3) continue;

    // ISO-TP First Frame (0x10..0x1F)
    if ( (d[0] & 0xF0) == 0x10 && dlc >= 6 ) {
      if (d[2] == 0x49 && d[3] == 0x02) {
        sawISOTP = true;
        for (uint8_t i = 5; i < dlc && vinlen < 31; i++) {
          char c = (char)d[i];
          if (c >= ' ' && c <= '~') vinbuf[vinlen++] = c;
        }
      }
      continue;
    }
    // ISO-TP Consecutive Frame (0x21..0x2F)
    if ( (d[0] & 0xF0) == 0x20 && dlc >= 2 ) {
      if (sawISOTP) {
        for (uint8_t i = 1; i < dlc && vinlen < 31; i++) {
          char c = (char)d[i];
          if (c >= ' ' && c <= '~') vinbuf[vinlen++] = c;
        }
      }
      continue;
    }

    // 49 02 01/02/03 chunked format
    if (dlc >= 4 && d[1] == 0x49 && d[2] == 0x02) {
      uint8_t part = d[3];               // 0x01..0x03
      if (part >= 1 && part <= 3) {
        uint8_t idx = part - 1;
        uint8_t start = 4;
        uint8_t len = dlc > start ? (dlc - start) : 0;
        if (len > 7) len = 7;
        for (uint8_t i=0; i<len; i++) partBuf[idx][i] = (char)d[start+i];
        partLen[idx] = len; gotPart[idx] = true;
      }
      continue;
    }
  }

  String vin;
  if (sawISOTP) {
    for (uint8_t i=0;i<vinlen;i++) if (vinbuf[i] != ' ') vin += vinbuf[i];
  } else {
    for (uint8_t p=0; p<3; p++) if (gotPart[p]) {
      for (uint8_t i=0; i<partLen[p]; i++) if (partBuf[p][i] != ' ') vin += partBuf[p][i];
    }
  }

  if (vin.length() >= 17) vin = vin.substring(0, 17);
  if (vin.length() >= 11) {
    vehicle_id = vin;
    Serial.printf("âœ… VIN detected: %s\n", vehicle_id.c_str());
  } else {
    Serial.println("âš  VIN not found, using default 'unknown'");
  }
}

// ---------------- OBD-II request/parse ----------------
// NOTE: We no longer push TX frames into the raw buffer; RX only.
// Also increments rx_count when any reply is received.
static void requestPID(uint8_t pid, Frame* out, int& idx, int max,
                       float& batt, float& coolant, float& rpm,
                       float& stft_b1, float& ltft_b1, float& stft_b2, float& ltft_b2,
                       long& runtime_s, int& rx_count)
{
  if (idx >= max) return;

  twai_message_t tx = {};
  tx.identifier = 0x7DF;               // functional broadcast
  tx.flags = TWAI_MSG_FLAG_NONE;       // 11-bit std
  tx.data_length_code = 8;
  tx.data[0] = 0x02;                    // 2 data bytes follow
  tx.data[1] = 0x01;                    // Service 01: current data
  tx.data[2] = pid;                     // PID
  tx.data[3] = tx.data[4] = tx.data[5] = tx.data[6] = tx.data[7] = 0x00;

  if (twai_transmit(&tx, pdMS_TO_TICKS(50)) == ESP_OK) {
    Serial.printf("ðŸ“¤ Sent STD PID 0x%02X on ID 0x7DF\n", pid);
  } else {
    Serial.printf("TX failed for PID 0x%02X\n", pid);
    return;
  }

  // Collect responses (typ. 0x7E8..0x7EF). Wait ~60 ms.
  uint32_t t0 = millis();
  while (millis() - t0 < 60 && idx < max) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(5)) == ESP_OK) {
      Frame f; pushFromMsg(f, rx);
      out[idx++] = f;         // <-- RX only
      rx_count++;             // mark that ECUs are awake

      // Positive response: 0x41; PID echoes in byte 2
      if ((rx.data_length_code >= 3) && rx.data[1] == 0x41 && rx.data[2] == pid) {
        uint8_t A = (rx.data_length_code > 3) ? rx.data[3] : 0;
        uint8_t B = (rx.data_length_code > 4) ? rx.data[4] : 0;
        uint8_t C = (rx.data_length_code > 5) ? rx.data[5] : 0; (void)C;
        uint8_t D = (rx.data_length_code > 6) ? rx.data[6] : 0; (void)D;

        switch (pid) {
          case 0x05: coolant   = decodeTemp(A);        break;
          case 0x0C: rpm       = decodeRPM(A,B);       break;
          case 0x42: batt      = decodeVoltage(A,B);   break;
          case 0x1F: runtime_s = decodeU16(A,B);       break;
          case 0x06: stft_b1   = decodeTrim(A);        break;
          case 0x07: ltft_b1   = decodeTrim(A);        break;
          case 0x08: stft_b2   = decodeTrim(A);        break;
          case 0x09: ltft_b2   = decodeTrim(A);        break;
        }
      }
    }
  }
}

// ---------------- Arduino entrypoints ----------------
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\nOLADS OBD-II poller â†’ Supabase (ignition-aware)");

  wifiConnect();
  secureClient.setInsecure();   // dev: skip CA; for prod, pin Let's Encrypt R3

  if (!canInitNormal()) {
    Serial.println("CAN init FAILED (check transceiver power, pins 22/21, termination)");
    while(1) delay(1000);
  }
  Serial.println("CAN NORMAL @ 500 kbps");

  // We will call requestVIN() later the first time we detect replies.
}

void loop() {
  ensureWifi();

  // Metrics weâ€™ll parse (start as NaN / -1)
  float batt=NAN, coolant=NAN, rpm=NAN, stft_b1=NAN, ltft_b1=NAN, stft_b2=NAN, ltft_b2=NAN;
  long runtime_s = -1;

  static Frame buf[128];
  int idx = 0;
  int rx_count = 0;

  // Query the PIDs you want:
  const uint8_t pids[] = {0x0C,0x05,0x42,0x1F,0x06,0x07,0x08,0x09};
  for (uint8_t pid : pids) {
    requestPID(pid, buf, idx, 128, batt, coolant, rpm, stft_b1, ltft_b1, stft_b2, ltft_b2, runtime_s, rx_count);
    delay(20);
  }

  // Print parsed results
  Serial.printf("VIN=%s  RX=%d  RPM=%.0f  Coolant=%.1fÂ°C  Batt=%.2fV  Runtime=%lds  STFT1=%.1f%%  LTFT1=%.1f%%  STFT2=%.1f%%  LTFT2=%.1f%%\n",
    vehicle_id.c_str(), rx_count, rpm, coolant, batt, runtime_s, stft_b1, ltft_b1, stft_b2, ltft_b2);

  // If ECUs just woke up and we don't have VIN yet, try now
  static bool triedVIN = false;
  if (!triedVIN && rx_count > 0 && vehicle_id == "unknown") {
    triedVIN = true;
    requestVIN();
  }

  // --- Send to Supabase ONLY if we got replies this loop ---
  if (rx_count > 0) {
    bool haveParsed = (!isnan(rpm) || !isnan(coolant) || !isnan(batt) ||
                       runtime_s >= 0 || !isnan(stft_b1) || !isnan(ltft_b1) ||
                       !isnan(stft_b2) || !isnan(ltft_b2));

    if (haveParsed) {
      postSensorData(batt, coolant, rpm, stft_b1, ltft_b1, stft_b2, ltft_b2, runtime_s);
    }

    if (idx > 0) {
      postRawFramesBatch(buf, idx);  // RX-only frames
    }
  } else {
    Serial.println("ECU appears asleep (vehicle OFF). Skipping uploads this cycle.");
  }

  // Poll every ~1s
  delay(1000);
}


