// ==== ESP32 OBD-II PID poller + Supabase ingest (TWAI NORMAL @ 500k) ====
// Pins: GPIO22 -> CTX, GPIO21 -> CRX

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "driver/twai.h"
#include <math.h>
#include <ctype.h>

// ---------- EDIT (Wi-Fi) ----------
const char* WIFI_SSID = "iPhone";
const char* WIFI_PASS = "american";

// ===== Supabase (REST) =====
String serverUrl    = "https://zhrlppnknfjxhwhfsdxd.supabase.co/rest/v1/sensor_data"; // parsed PIDs
String rawUrl       = "https://zhrlppnknfjxhwhfsdxd.supabase.co/rest/v1/can_raw";      // raw frames
String SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpocmxwcG5rbmZqeGh3aGZzZHhkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1NjY3NjIsImV4cCI6MjA3MjE0Mjc2Mn0.EVrzx09YwDglwFUCjS3hKbrg2Wdy1hjSPV1gWxnN_yU";

// Will be set from Mode 09 PID 02 (VIN) at startup:
String vehicle_id   = "unknown";

#define TWAI_TX_PIN GPIO_NUM_22
#define TWAI_RX_PIN GPIO_NUM_21

struct Frame {
  uint32_t ts;
  uint32_t id;
  uint8_t  dlc;
  uint8_t  data[8];
  bool     is_ext;
};

WiFiClientSecure secureClient;
HTTPClient http;

// ---------------- Wi-Fi ----------------
static bool wifiConnect() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi");
  uint32_t t0 = millis();
  while (WiFi.status()!=WL_CONNECTED && millis()-t0<20000) { delay(300); Serial.print("."); }
  Serial.println();
  if (WiFi.status()==WL_CONNECTED) {
    Serial.printf("WiFi OK, IP: %s\n", WiFi.localIP().toString().c_str());
    return true;
  }
  Serial.println("WiFi FAILED");
  return false;
}

// ---------------- CAN/TWAI ----------------
static bool canInitNormal() {
  twai_general_config_t g = TWAI_GENERAL_CONFIG_DEFAULT(TWAI_TX_PIN, TWAI_RX_PIN, TWAI_MODE_NORMAL);
  twai_timing_config_t  t = TWAI_TIMING_CONFIG_500KBITS();   // OBD-II 500k
  twai_filter_config_t  f = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  if (twai_driver_install(&g, &t, &f) != ESP_OK) return false;
  if (twai_start() != ESP_OK) return false;
  return true;
}

static void pushFromMsg(Frame& dst, const twai_message_t& m) {
  dst.ts  = millis();
  bool ext = (m.flags & TWAI_MSG_FLAG_EXTD);
  dst.id  = ext ? m.identifier : (m.identifier & 0x7FF);
  dst.is_ext = ext;
  dst.dlc = m.data_length_code;
  for (int i=0;i<dst.dlc && i<8;i++) dst.data[i] = m.data[i];
}

// ---------------- Supabase helpers ----------------
static bool supabasePostJson(const String& url, const String& payload) {
  if (!http.begin(secureClient, url)) { Serial.println("HTTP begin failed"); return false; }
  http.addHeader("Content-Type", "application/json");
  http.addHeader("apikey", SUPABASE_KEY);
  http.addHeader("Authorization", "Bearer " + SUPABASE_KEY);
  http.addHeader("Prefer", "return=minimal"); // faster, no echo
  int code = http.POST((uint8_t*)payload.c_str(), payload.length());
  String resp = http.getString();
  Serial.printf("POST %d to %s\n", code, url.c_str());
  if (code < 200 || code >= 300) {
    Serial.println(resp);
    http.end();
    return false;
  }
  http.end();
  return true;
}

// Post one parsed sensor row to public.sensor_data
static bool postSensorData(
  float batt, float coolant, float rpm,
  float stft_b1, float ltft_b1, float stft_b2, float ltft_b2,
  long runtime_s
) {
  StaticJsonDocument<512> doc;
  doc["vehicle_id"] = vehicle_id;
  if (!isnan(batt))      doc["batt"]      = batt;
  if (!isnan(coolant))   doc["coolant"]   = coolant;
  if (!isnan(rpm))       doc["rpm"]       = rpm;
  if (!isnan(stft_b1))   doc["stft_b1"]   = stft_b1;
  if (!isnan(ltft_b1))   doc["ltft_b1"]   = ltft_b1;
  if (!isnan(stft_b2))   doc["stft_b2"]   = stft_b2;
  if (!isnan(ltft_b2))   doc["ltft_b2"]   = ltft_b2;
  if (runtime_s >= 0)    doc["runtime_s"] = runtime_s;

  String payload; serializeJson(doc, payload);
  return supabasePostJson(serverUrl, payload);
}

static String toHexBytes(const uint8_t* data, uint8_t len) {
  char buf[3];
  String s;
  for (uint8_t i=0;i<len;i++) {
    if (i) s += ' ';
    snprintf(buf, sizeof(buf), "%02X", data[i]);
    s += buf;
  }
  return s;
}

// Batch-post raw frames to public.can_raw (as an array)
static bool postRawFramesBatch(const Frame* frames, int count) {
  StaticJsonDocument<8192> doc;
  JsonArray arr = doc.to<JsonArray>();

  for (int i=0;i<count;i++) {
    JsonObject r = arr.createNestedObject();
    r["vehicle_id"] = vehicle_id;
    r["can_id"]     = (int)frames[i].id;
    r["is_ext"]     = frames[i].is_ext;
    r["dlc"]        = (int)frames[i].dlc;
    r["data_hex"]   = toHexBytes(frames[i].data, frames[i].dlc);
    r["ts_ms"]      = (long long)frames[i].ts;
  }

  String payload; serializeJson(doc, payload);
  return supabasePostJson(rawUrl, payload);
}

// ---------------- OBD-II decoders ----------------
static float decodeTemp(uint8_t A){ return (float)A - 40.0f; }                     // PID 05 (Â°C)
static float decodeRPM(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/4.0f; }         // PID 0C (rpm)
static float decodeVoltage(uint8_t A,uint8_t B){ return ((A*256.0f)+B)/1000.0f; }  // PID 42 (V)
static float decodeTrim(uint8_t A){ return ((float)A - 128.0f) * 100.0f / 128.0f; }// PIDs 06â€“09 (%)
static long  decodeU16(uint8_t A,uint8_t B){ return (long)(A*256 + B); }           // PID 1F (s)

// Reassembles VIN from both ISO-TP multi-frame and 49 02 chunked replies
static void requestVIN() {
  twai_message_t tx = {};
  tx.identifier = 0x7DF;
  tx.flags = TWAI_MSG_FLAG_NONE;   // 11-bit
  tx.data_length_code = 8;
  tx.data[0] = 0x02;               // 2 data bytes
  tx.data[1] = 0x09;               // Service 09
  tx.data[2] = 0x02;               // PID 02 = VIN
  tx.data[3] = tx.data[4] = tx.data[5] = tx.data[6] = tx.data[7] = 0x00;

  if (twai_transmit(&tx, pdMS_TO_TICKS(50)) == ESP_OK) {
    Serial.println("ðŸ“¤ Sent request for VIN (09 02)");
  } else {
    Serial.println("TX failed for VIN");
    return;
  }

  char vinbuf[32]; uint8_t vinlen = 0;
  // For 49 02 01/02/03 style
  char partBuf[3][8]; uint8_t partLen[3] = {0,0,0}; bool gotPart[3] = {false,false,false};
  bool sawISOTP = false;

  uint32_t t0 = millis();
  while (millis() - t0 < 1200) {  // give ECUs time to stream
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(20)) != ESP_OK) continue;

    const uint8_t *d = rx.data;
    uint8_t dlc = rx.data_length_code;

    if (dlc < 3) continue;

    // ISO-TP First Frame? (0x10 to 0x1F in high nibble)
    if ( (d[0] & 0xF0) == 0x10 && dlc >= 6 ) {
      // d[0:1] total len, then payload starts at d[2]
      // Expect d[2]=0x49, d[3]=0x02, d[4]=0x01 then VIN bytes from d[5..]
      if (d[2] == 0x49 && d[3] == 0x02) {
        sawISOTP = true;
        for (uint8_t i = 5; i < dlc && vinlen < 31; i++) {
          char c = (char)d[i];
          if (c >= ' ' && c <= '~') vinbuf[vinlen++] = c;
        }
      }
      continue;
    }

    // ISO-TP Consecutive Frame? (0x21..0x2F)
    if ( (d[0] & 0xF0) == 0x20 && dlc >= 2 ) {
      if (sawISOTP) {
        for (uint8_t i = 1; i < dlc && vinlen < 31; i++) {
          char c = (char)d[i];
          if (c >= ' ' && c <= '~') vinbuf[vinlen++] = c;
        }
      }
      continue;
    }

    // ELM-style single-chunk replies: 49 02 01/02/03 in d[1], d[2], d[3]
    if (dlc >= 4 && d[1] == 0x49 && d[2] == 0x02) {
      uint8_t part = d[3];               // 0x01..0x03
      if (part >= 1 && part <= 3) {
        uint8_t idx = part - 1;
        uint8_t start = 4;
        uint8_t len = dlc > start ? (dlc - start) : 0;
        if (len > 7) len = 7;
        for (uint8_t i=0; i<len; i++) partBuf[idx][i] = (char)d[start+i];
        partLen[idx] = len; gotPart[idx] = true;
      }
      continue;
    }
  }

  String vin;
  if (sawISOTP) {
    // ISO-TP path wins if we got it
    vin.reserve(vinlen);
    for (uint8_t i=0;i<vinlen;i++) if (vinbuf[i] != ' ') vin += vinbuf[i];
  } else {
    // Stitch 49 02 01/02/03
    for (uint8_t p=0; p<3; p++) if (gotPart[p]) {
      for (uint8_t i=0; i<partLen[p]; i++) if (partBuf[p][i] != ' ') vin += partBuf[p][i];
    }
  }

  if (vin.length() >= 17) vin = vin.substring(0, 17);
  if (vin.length() >= 11) {
    vehicle_id = vin;
    Serial.printf("âœ… VIN detected: %s\n", vehicle_id.c_str());
  } else {
    Serial.println("âš  VIN not found, using default 'unknown'");
  }
}

// ---------------- OBD-II request/parse ----------------
static void requestPID(uint8_t pid, Frame* out, int& idx, int max,
                       float& batt, float& coolant, float& rpm,
                       float& stft_b1, float& ltft_b1, float& stft_b2, float& ltft_b2,
                       long& runtime_s)
{
  if (idx >= max) return;

  twai_message_t tx = {};
  tx.identifier = 0x7DF;               // functional broadcast
  tx.flags = TWAI_MSG_FLAG_NONE;       // 11-bit std
  tx.data_length_code = 8;
  tx.data[0] = 0x02;                    // 2 data bytes follow
  tx.data[1] = 0x01;                    // Service 01: current data
  tx.data[2] = pid;                     // PID
  tx.data[3] = tx.data[4] = tx.data[5] = tx.data[6] = tx.data[7] = 0x00;

  if (twai_transmit(&tx, pdMS_TO_TICKS(50)) == ESP_OK) {
    Frame f; pushFromMsg(f, tx);
    if (idx < max) out[idx++] = f;
    Serial.printf("ðŸ“¤ Sent STD PID 0x%02X on ID 0x7DF\n", pid);
  } else {
    Serial.printf("TX failed for PID 0x%02X\n", pid);
    return;
  }

  // Collect responses (typ. 0x7E8..0x7EF). Wait ~60 ms.
  uint32_t t0 = millis();
  while (millis() - t0 < 60 && idx < max) {
    twai_message_t rx;
    if (twai_receive(&rx, pdMS_TO_TICKS(5)) == ESP_OK) {
      Frame f; pushFromMsg(f, rx);
      out[idx++] = f;

      // Positive response: 0x41; PID echoes in byte 2
      if ((rx.data_length_code >= 3) && rx.data[1] == 0x41 && rx.data[2] == pid) {
        uint8_t A = (rx.data_length_code > 3) ? rx.data[3] : 0;
        uint8_t B = (rx.data_length_code > 4) ? rx.data[4] : 0;
        uint8_t C = (rx.data_length_code > 5) ? rx.data[5] : 0; (void)C;
        uint8_t D = (rx.data_length_code > 6) ? rx.data[6] : 0; (void)D;

        switch (pid) {
          case 0x05: coolant   = decodeTemp(A);        break;
          case 0x0C: rpm       = decodeRPM(A,B);       break;
          case 0x42: batt      = decodeVoltage(A,B);   break;
          case 0x1F: runtime_s = decodeU16(A,B);       break;
          case 0x06: stft_b1   = decodeTrim(A);        break;
          case 0x07: ltft_b1   = decodeTrim(A);        break;
          case 0x08: stft_b2   = decodeTrim(A);        break;
          case 0x09: ltft_b2   = decodeTrim(A);        break;
        }
      }
    }
  }
}

// ---------------- Arduino entrypoints ----------------
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\nOLADS OBD-II poller â†’ Supabase");
  Serial.println(serverUrl);
  Serial.println(rawUrl);

  wifiConnect();

  // For dev/testing: accept all certs (for production, pin Let's Encrypt R3 CA)
  secureClient.setInsecure();

  if (!canInitNormal()) {
    Serial.println("CAN init FAILED (3.3V transceiver, pins 22/21, RS/EN low, 500k, termination OK)");
    while(1) delay(1000);
  }
  Serial.println("CAN NORMAL @ 500 kbps");

  // Fetch VIN once and use as vehicle_id for all inserts
  requestVIN();
}

void loop() {
  // Metrics weâ€™ll parse (start as NaN / -1)
  float batt=NAN, coolant=NAN, rpm=NAN, stft_b1=NAN, ltft_b1=NAN, stft_b2=NAN, ltft_b2=NAN;
  long runtime_s = -1;

  static Frame buf[128];
  int idx = 0;

  // Query the PIDs you want:
  const uint8_t pids[] = {0x0C,0x05,0x42,0x1F,0x06,0x07,0x08,0x09};
  for (uint8_t pid : pids) {
    requestPID(pid, buf, idx, 128, batt, coolant, rpm, stft_b1, ltft_b1, stft_b2, ltft_b2, runtime_s);
    delay(20);
  }

  // Print parsed results
  Serial.printf("VIN=%s  RPM=%.0f  Coolant=%.1fÂ°C  Batt=%.2fV  Runtime=%lds  STFT1=%.1f%%  LTFT1=%.1f%%  STFT2=%.1f%%  LTFT2=%.1f%%\n",
    vehicle_id.c_str(), rpm, coolant, batt, runtime_s, stft_b1, ltft_b1, stft_b2, ltft_b2);

  // --- Send to Supabase ---
  if (!isnan(rpm) || !isnan(coolant) || !isnan(batt) || runtime_s >= 0 ||
      !isnan(stft_b1) || !isnan(ltft_b1) || !isnan(stft_b2) || !isnan(ltft_b2)) {
    postSensorData(batt, coolant, rpm, stft_b1, ltft_b1, stft_b2, ltft_b2, runtime_s);
  }

  if (idx > 0) {
    // If memory becomes tight with very large batches, split into chunks (e.g., 32 at a time).
    postRawFramesBatch(buf, idx);
  }

  // Poll every ~1s
  delay(1000);
}

