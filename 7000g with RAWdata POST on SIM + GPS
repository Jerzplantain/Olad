/*
  LilyGO T-SIM7000G + TinyGSM + GNSS + CAN (TWAI) + Supabase POST (batched)
  Provider: Hologram (LTE-M) â€” attaches PDP only when posting to minimize data use

  Supabase table: public.can_raw
  Fields: frame_id (int), extd (bool), dlc (smallint), t_us (bigint), data_hex (text), bus_id (smallint, default 0)
*/

#define TINY_GSM_MODEM_SIM7000
#define TINY_GSM_RX_BUFFER 1024
// NOTE: No TinyGsmClientSecure needed when using SIM7000 HTTPS AT commands

#define SerialAT  Serial1
#define SerialMon Serial

// -------- Hologram (APN) --------
const char apn[] = "hologram";
const char gprsUser[] = "";
const char gprsPass[] = "";
#define GSM_PIN ""   // SIM PIN if any

// ---- Includes ----
#include <TinyGsmClient.h>   // modem control & PPP (no secure client used)
#include <SPI.h>
#include <SD.h>

// ESP32 built-in CAN controller (TWAI)
#include "driver/twai.h"

// ---- Pins: LilyGO T-SIM7000G ----
#define UART_BAUD   115200
#define PIN_DTR     25     // Keep LOW to prevent sleep
#define PIN_TX      27     // SIM7000 UART TX (ESP RX)
#define PIN_RX      26     // SIM7000 UART RX (ESP TX)
#define PIN_PWRKEY  4
#define LED_PIN     12

#define SD_MISO     2
#define SD_MOSI     15
#define SD_SCLK     14
#define SD_CS       13

// ---- ESP32 TWAI (CAN) pins ----
#define CAN_TX_PIN  33   // your current wiring
#define CAN_RX_PIN  32
#define CAN_TIMING  TWAI_TIMING_CONFIG_500KBITS()

// AT bridge toggle (non-blocking either way)
#define AT_BRIDGE_ENABLED 1

// ---- Supabase (REST) ----
TinyGsm modem(SerialAT);

// Project + table endpoint
static const char *SB_HOST = "zhrlppnknfjxhwhfsdxd.supabase.co";
static const char *SB_PATH = "/rest/v1/can_raw";
static const int   SB_PORT = 443;

// Your anon key (Bearer)
static const char *SB_KEY  = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpocmxwcG5rbmZqeGh3aGZzZHhkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1NjY3NjIsImV4cCI6MjA3MjE0Mjc2Mn0.EVrzx09YwDglwFUCjS3hKbrg2Wdy1hjSPV1gWxnN_yU";

// Posting controls
#define POST_ENABLE        1          // set to 0 to disable posting
#define POST_INTERVAL_MS   10000UL    // batch interval (10 s)
#define POST_DISCONNECT    1          // disconnect PDP after posting to save data
#define BUS_ID_DEFAULT     0          // optional bus labeling (0=HS)

// ====================== Helpers ======================

// -------- Modem power helpers --------
static inline void modemPowerKeyPulse() {
  pinMode(PIN_PWRKEY, OUTPUT);
  digitalWrite(PIN_PWRKEY, LOW);
  delay(1000);
  digitalWrite(PIN_PWRKEY, HIGH);
}
static inline void modemStart() { modemPowerKeyPulse(); }
static inline void modemRestartHard() {
  modemPowerKeyPulse();
  delay(1200);
  modemPowerKeyPulse();
}

// -------- GNSS helpers --------
bool enableGNSS() {
  SerialMon.println("Enabling GNSS...");
  if (!modem.enableGPS()) {
    SerialMon.println("Failed to enable GNSS (enableGPS() returned false).");
    return false;
  }
  return true;
}
bool readGNSSOnce(float &lat, float &lon, float &alt, float &acc, int &vsat, int &usat, float &speed) {
  return modem.getGPS(&lat, &lon, &speed, &alt, &vsat, &usat, &acc);
}
void printGNSS(float lat, float lon, float alt, float acc, int vsat, int usat, float speed) {
  SerialMon.printf("GNSS: lat=%.6f lon=%.6f alt=%.1f m acc=%.1f m sats(view/used)=%d/%d speed=%.1f m/s\n",
                   lat, lon, alt, acc, vsat, usat, speed);
  SerialMon.printf("Maps: https://maps.google.com/?q=%.6f,%.6f\n", lat, lon);
}

// -------- CAN helpers --------
static inline const char* canFrameTypeStr(const twai_message_t &msg) {
  return msg.extd ? "EXT" : "STD";
}
static inline void printCanFrame(const twai_message_t &msg, uint32_t us) {
  SerialMon.printf("CAN %s 0x%08lX  DLC=%d  DATA=",
                   canFrameTypeStr(msg), (unsigned long)msg.identifier, msg.data_length_code);
  for (int i = 0; i < msg.data_length_code; i++) {
    SerialMon.printf("%02X", msg.data[i]);
    if (i < msg.data_length_code - 1) SerialMon.print(' ');
  }
  if (msg.rtr) SerialMon.print(" RTR");
  SerialMon.printf("  t=%lu us\n", (unsigned long)us);
}

// JSON for our schema
String frameToJsonSchema(const twai_message_t &msg, uint32_t microsNow, int bus_id = BUS_ID_DEFAULT) {
  String json = "{";
  json += "\"frame_id\":" + String(msg.identifier);
  json += ",\"extd\":" + String(msg.extd ? "true" : "false");
  json += ",\"dlc\":" + String(msg.data_length_code);
  json += ",\"t_us\":" + String(microsNow);
  json += ",\"bus_id\":" + String(bus_id);
  json += ",\"data_hex\":\"";
  for (int i = 0; i < msg.data_length_code; i++) {
    if (i) json += " ";
    char buf[4];
    sprintf(buf, "%02X", msg.data[i]);
    json += buf;
  }
  json += "\"}";
  return json;
}

// -------- CAN init --------
bool initCAN() {
  twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT((gpio_num_t)CAN_TX_PIN, (gpio_num_t)CAN_RX_PIN, TWAI_MODE_NORMAL);
  twai_timing_config_t  t_config = CAN_TIMING;
  twai_filter_config_t  f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  if (twai_driver_install(&g_config, &t_config, &f_config) != ESP_OK) {
    SerialMon.println("TWAI driver install FAILED");
    return false;
  }
  if (twai_start() != ESP_OK) {
    SerialMon.println("TWAI start FAILED");
    twai_driver_uninstall();
    return false;
  }
  SerialMon.println("TWAI (CAN) started @ 500 kbps");
  return true;
}

// -------- Data session helpers --------
bool ensurePDP() {
  if (modem.isGprsConnected()) return true;
  SerialMon.println("Connecting PDP for posting...");
  if (!modem.gprsConnect(apn, gprsUser, gprsPass)) {
    SerialMon.println("PDP attach failed.");
    return false;
  }
  return true;
}
void maybeDisconnectPDP() {
  if (POST_DISCONNECT && modem.isGprsConnected()) {
    SerialMon.println("Disconnecting PDP to save data...");
    modem.gprsDisconnect();
  }
}

// -------- HTTPS POST via SIM7000 AT commands --------
// Uses: CHTTPSTART/OPSE/HEADER/POST/CLSE/STOP
bool postBatchToSupabase_AT(const String &payload) {
  if (!ensurePDP()) return false;

  String res;

  // Start HTTPS stack
  modem.sendAT("+CHTTPSSTART");
  if (modem.waitResponse(10000L) != 1) {
    SerialMon.println("CHTTPSSTART failed (already started is OK).");
  }

  // Open secure connection (mode 2 = TLS)
  modem.sendAT("+CHTTPSOPSE=\"", SB_HOST, "\",", SB_PORT, ",2");
  if (modem.waitResponse(20000L) != 1) {
    SerialMon.println("CHTTPSOPSE failed");
    goto close_stop_fail;
  }

  // Clear/set headers
  modem.sendAT("+CHTTPSHEADER=1");          // enable custom headers
  modem.waitResponse(5000L);

  modem.sendAT("+CHTTPSHEADER=\"Content-Type: application/json\"");
  modem.waitResponse(5000L);

  modem.sendAT("+CHTTPSHEADER=\"apikey: ", SB_KEY, "\"");
  modem.waitResponse(5000L);

  modem.sendAT("+CHTTPSHEADER=\"Authorization: Bearer ", SB_KEY, "\"");
  modem.waitResponse(5000L);

  // POST path with body length and timeout (seconds)
  modem.sendAT("+CHTTPSPOST=\"", SB_PATH, "\",", payload.length(), ",120");
  if (modem.waitResponse(10000L, res) != 1) {
    SerialMon.println("CHTTPSPOST (prep) failed");
    goto close_stop_fail;
  }

  // Module should respond with "DOWNLOAD" then we send body
  // (TinyGSM waitResponse already captured it in 'res' sometimes; we proceed to write body)
  SerialMon.println("Sending body...");
  SerialAT.write((const uint8_t*)payload.c_str(), payload.length());

  // Wait for POST result
  if (modem.waitResponse(30000L, res) != 1) {
    SerialMon.println("No POST result");
    goto close_stop_fail;
  }
  res.trim();
  SerialMon.println(res);

  // Optional: receive a chunk (not strictly needed with Prefer:return=minimal)
  modem.sendAT("+CHTTPSRECV=256");
  modem.waitResponse(5000L, res);
  res.trim(); if (res.length()) SerialMon.println(res);

  // Close & stop
  modem.sendAT("+CHTTPSCLSE");
  modem.waitResponse(10000L);
  modem.sendAT("+CHTTPSSTOP");
  modem.waitResponse(10000L);

  return true;

close_stop_fail:
  modem.sendAT("+CHTTPSCLSE");
  modem.waitResponse(10000L);
  modem.sendAT("+CHTTPSSTOP");
  modem.waitResponse(10000L);
  return false;
}

// ====================== Setup ======================
void setup() {
  SerialMon.begin(115200);
  delay(10);

  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, HIGH);

  // Keep modem awake
  pinMode(PIN_DTR, OUTPUT);
  digitalWrite(PIN_DTR, LOW);

  // SD (optional)
  SerialMon.println("======== SDCard Detect ========");
  SPI.begin(SD_SCLK, SD_MISO, SD_MOSI);
  if (!SD.begin(SD_CS)) {
    SerialMon.println("SDCard MOUNT FAIL");
  } else {
    uint32_t cardSize = SD.cardSize() / (1024UL * 1024UL);
    SerialMon.print("SDCard Size: ");
    SerialMon.print(cardSize);
    SerialMon.println(" MB");
  }
  SerialMon.println("================================");

  // Modem UART
  SerialAT.begin(UART_BAUD, SERIAL_8N1, PIN_RX, PIN_TX);

  // Wake/Start modem
  modemStart();

  // Init CAN (TWAI)
  initCAN();

  SerialMon.println("\n--- T-SIM7000G + Hologram init (PDP only on post) ---");
}

// State flags for modem & GNSS
bool modemInited   = false;
bool gnssTried     = false;
bool gnssGotFix    = false;
unsigned long gnssPollLast = 0;

// Batch buffer for CAN frames
String batch = "[";
unsigned long lastPost = 0;

// ====================== Loop ======================
void loop() {
  String res;

  // 1) MODEM INIT & LTE registration (no PDP yet)
  if (!modemInited) {
    SerialMon.println("\n======== INIT MODEM ========");
    if (!modem.init()) {
      SerialMon.println("modem.init() failed, trying hard restart...");
      modemRestartHard();
      delay(2000);
      if (!modem.init()) {
        SerialMon.println("Modem failed to init again. Check power/antenna/SIM.");
        delay(500);
        return;
      }
    }

    // Identify modem
    SerialMon.println("Query modem:");
    modem.sendAT("+SIMCOMATI");
    if (modem.waitResponse(2000L, res) == 1) {
      res.replace("\r\nOK\r\n", "");
      SerialMon.println(res);
    }
    res = "";

    // RAT/bands for Hologram (US)
    modem.sendAT("+CNMP=38"); modem.waitResponse(2000L); // LTE only
    modem.sendAT("+CMNB=1");  modem.waitResponse(2000L); // CAT-M only
    modem.sendAT("+CBANDCFG=\"CAT-M\",\"B2,B4,B12\""); modem.waitResponse(2000L);

    // Confirm settings
    modem.sendAT("+CNMP?");     modem.waitResponse(2000L, res); SerialMon.println(res); res="";
    modem.sendAT("+CMNB?");     modem.waitResponse(2000L, res); SerialMon.println(res); res="";
    modem.sendAT("+CBANDCFG?"); modem.waitResponse(2000L, res); SerialMon.println(res); res="";

    // SIM unlock if needed
    if (GSM_PIN[0] && modem.getSimStatus() != 3) modem.simUnlock(GSM_PIN);

    // Wait for network registration (NO PDP yet)
    SerialMon.println("Waiting for LTE-M network (no data session)...");
    bool netOK = false;
    for (int i = 0; i < 60; i++) {
      int16_t sig = modem.getSignalQuality();
      bool reg   = modem.isNetworkConnected();
      SerialMon.print("Signal: "); SerialMon.print(sig);
      SerialMon.print("  Reg: "); SerialMon.println(reg ? "YES" : "NO");
      if (reg) { netOK = true; break; }
      digitalWrite(LED_PIN, !digitalRead(LED_PIN));
      delay(1000);
    }
    digitalWrite(LED_PIN, HIGH);

    if (!netOK) {
      SerialMon.println("No network yet. Will retry next loop.");
      delay(500);
      return;
    }

    // System Info (optional)
    SerialMon.println("===== CPSI (System Info) =====");
    modem.sendAT("+CPSI?");
    if (modem.waitResponse(3000L, res) == 1) {
      res.replace("\r\nOK\r\n", "");
      SerialMon.println(res);
    }

    modemInited = true;
    SerialMon.println("Modem ready (registered). PDP will attach only when posting.");
  }

  // 2) GNSS: turn on once and poll until a real fix is obtained (stay enabled)
  if (!gnssTried) {
    SerialMon.println("Turning GNSS on and starting cold start sequence...");
    bool gpsOK = enableGNSS();
    if (!gpsOK) SerialMon.println("TinyGSM enableGPS() reported false (continuing with AT commands).");

    modem.sendAT("+CGNSPWR=1");   modem.waitResponse(2000L);
    modem.sendAT("+CGNSMOD=1");   modem.waitResponse(2000L);     // standalone (optional)
    modem.sendAT("+CGNSSEQ=\"RMC\""); modem.waitResponse(2000L);
    modem.sendAT("+CGNSCOLD");    modem.waitResponse(2000L);      // cold start once
    gnssTried = true;
    gnssPollLast = 0; // force immediate poll
  }

  // Poll GNSS once per second (non-blocking)
  if (gnssTried && !gnssGotFix) {
    unsigned long now = millis();
    if (now - gnssPollLast >= 1000) {
      gnssPollLast = now;

      String inf;
      modem.sendAT("+CGNSINF");
      if (modem.waitResponse(3000L, inf) == 1) {
        inf.trim(); inf.replace("\r\nOK\r\n", "");
        SerialMon.println(inf); // raw status
        float lat=0, lon=0, alt=0, acc=0, speed=0;
        int vsat=0, usat=0;
        if (readGNSSOnce(lat, lon, alt, acc, vsat, usat, speed)) {
          if (lat != 0.0f || lon != 0.0f) {
            printGNSS(lat, lon, alt, acc, vsat, usat, speed);
            gnssGotFix = true;
          }
        }
      } else {
        SerialMon.println("No response to +CGNSINF this cycle.");
      }
    }
  }

  // 3) CAN: read and print any available frames (non-blocking), and add to batch
  twai_message_t rx_msg;
  while (twai_receive(&rx_msg, 0) == ESP_OK) {   // 0 timeout = non-blocking
    uint32_t ts = micros();
    printCanFrame(rx_msg, ts); // local console

    if (POST_ENABLE) {
      String one = frameToJsonSchema(rx_msg, ts, BUS_ID_DEFAULT);
      if (batch.length() > 1) batch += ",";
      batch += one;
    }
  }

  // 4) If it's time, POST the batch (via SIM7000 HTTPS AT)
  if (POST_ENABLE && (millis() - lastPost >= POST_INTERVAL_MS) && batch.length() > 1) {
    String payload = batch + "]";
    SerialMon.printf("Posting %u bytes of CAN batch (AT HTTPS)...\n", (unsigned)payload.length());
    bool ok = postBatchToSupabase_AT(payload);
    if (ok) {
      SerialMon.println("POST OK");
      batch = "[";
      lastPost = millis();
    } else {
      SerialMon.println("POST FAILED (batch retained; will retry next interval)");
      // Keep batch to retry; watch size in low-signal situations.
    }
    maybeDisconnectPDP();  // drop PDP to save data
  }

  // 5) Optional: AT bridge (non-blocking)
  if (AT_BRIDGE_ENABLED) {
    while (SerialAT.available()) {
      SerialMon.write(SerialAT.read());
    }
    while (SerialMon.available()) {
      SerialAT.write(SerialMon.read());
    }
  }

  delay(5);
}
